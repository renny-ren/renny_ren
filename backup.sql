-- MySQL dump 10.13  Distrib 5.7.17, for Linux (x86_64)
--
-- Host: localhost    Database: blog
-- ------------------------------------------------------
-- Server version	5.7.17-0ubuntu0.16.04.1

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `ar_internal_metadata`
--

DROP TABLE IF EXISTS `ar_internal_metadata`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `ar_internal_metadata` (
  `key` varchar(255) NOT NULL,
  `value` varchar(255) DEFAULT NULL,
  `created_at` datetime NOT NULL,
  `updated_at` datetime NOT NULL,
  PRIMARY KEY (`key`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ar_internal_metadata`
--

LOCK TABLES `ar_internal_metadata` WRITE;
/*!40000 ALTER TABLE `ar_internal_metadata` DISABLE KEYS */;
INSERT INTO `ar_internal_metadata` VALUES ('environment','development','2017-03-09 09:50:49','2017-03-09 09:50:49');
/*!40000 ALTER TABLE `ar_internal_metadata` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `archives`
--

DROP TABLE IF EXISTS `archives`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `archives` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `created_at` datetime NOT NULL,
  `updated_at` datetime NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `archives`
--

LOCK TABLES `archives` WRITE;
/*!40000 ALTER TABLE `archives` DISABLE KEYS */;
/*!40000 ALTER TABLE `archives` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `articles`
--

DROP TABLE IF EXISTS `articles`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `articles` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) DEFAULT NULL,
  `content` text,
  `content_md` text,
  `date` varchar(255) DEFAULT NULL,
  `tag` text,
  `created_at` datetime NOT NULL,
  `updated_at` datetime NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `articles`
--

LOCK TABLES `articles` WRITE;
/*!40000 ALTER TABLE `articles` DISABLE KEYS */;
INSERT INTO `articles` VALUES (1,'速递易工作总结及感想','<p>　　<a href=\"https://yii.im/posts/some-reflections-on-the-twice-changes-of-sudiyi-wechat-team/\">&quot;在写这篇文章之前，我有点犹豫是否应当隐去公司的名字，一番思量之后还是决定不去在意这些细节。如果通篇都用某某来代替，难免写起来枯燥无味，况且，我要写的又不是什么坏事。&quot;</a></p>\n\n<p>　　时间过得飞快，一转眼我都实习了快5个月了。</p>\n\n<h3>工作总结</h3>\n\n<p>　　我把目前为止所做的工作分为三个阶段来总结：</p>\n\n<p>　　<strong>第一阶段</strong>是学习阶段，作为一个实习生，我的主要任务是学习基础知识，只有把基础的知识掌握好了才能谈其他东西。</p>\n\n<p>　　这个阶段我主要是看了三本书，分别是《Programming Ruby》、《ruby基础教程》和《rails tutorial》。</p>\n\n<p>　　入职前我得到了《Programming Ruby》《ruby基础教程》这两本书，我要求自己在入职之前的9天内把他们啃掉，一共1424页，这对我来说是一个不小的挑战，因为毕竟这是技术书籍，不是看小说，边看还要边理解、学习。刚接触ruby没多久，不懂的东西太多了，于是国庆节7天我就待在家里死磕，每天除了吃饭睡觉都是在学这个东西。最后我也基本完成了这个目标。</p>\n\n<p>　　通过这次学习，我掌握了很多ruby和rails相关的基础知识。从这个阶段中总结的一个经验就是，学一门语言首要解决的问题是迟迟不肯开始动手，如果只是看书而没有实际的练习就很容易忘掉，最后等书全部看完忘得也差不多了。所以务必要尽快进入实操的阶段，尽量通过解决实际问题来整合知识、巩固知识并加深理解。</p>\n\n<p>　　之后我做了一个日志练习学会相关的操作，包括状态码计数、相关gem的使用、代码的优化、重构等等，我认为这是一个很好的入门练习，所涉及的知识很全面，基本涵盖了我之前学到的所有基础知识，同时也加深了我的理解。这个练习我重构了三次，可以看到每次都有所进步，最后的效果是明显的，和刚开始写出来的东西相比优化了很多。</p>\n\n<p>　　这个做完之后我开始写爬虫来抓取某网站的一些数据，然后在后台展示出来。这是我第一次接触爬虫，通过这个练习也学到了很多知识，后台框架先是用了sinatra后用rails，帮助我更加了解了这两个框架。\n<h3> </h3>\n　　<strong>第二阶段</strong>是接触项目的阶段，基础的东西学完了，我开始接触公司的实际项目，这是我第一次看到真实的项目代码是什么样子。</p>\n\n<p>　　刚开始是一头雾水的，每块内容单独来看虽然好像看得懂，但我不清楚到底做了些什么，不清楚它们的内在联系或是一些细节的东西。我甚至连把项目跑起来都花了很长的时间。</p>\n\n<p>　　通过这个阶段，我开始更多地和公司其他人有了交流合作，相对来说公司的项目代码比一些其他的个人写的代码更加规范，更有可读性和学习价值。</p>\n\n<p>　　我了解了一些开发流程，学会了一些技能和方法（比如git相关操作），第一次接触了前后端分离，也了解了一个公司里面的各个部门的员工到底是在做些什么事情（以前我不知道公司要分产品、测试、前端后端这些部门，学校可不会教这些东西，我以为这些都是一个人做的）。\n<h3> </h3>\n　　<strong>第三阶段</strong>是参与开发的阶段，正好公司有新项目来了，这次我参与了某系统的开发，从需求分析，出原型，讨论修改，到后端开发，前端开发，联调，测试等，我第一次经历了这个完整的开发流程。</p>\n\n<p>　　说实话学到的干货不是很多，但是更多的是学到了一个项目从构思到最后完成要经历哪些过程，我觉得这个就和修房子是一样的，先作好图纸规划，打好地基，然后一步步往上建造，最后竣工。除此之外还锻炼了我的团队协作能力、交流沟通能力等，更重要的是解决问题的能力。</p>\n\n<p>　　我想一个程序员很重要的两个能力就是超强的自学能力和分析解决问题的能力。当我实习完后，可能这些项目若干年后也没用了，就是一堆符号而已，若干年后我自己回去看我写的这些代码可能也看不懂了，但是解决问题的能力是很重要的，这个报错完了还会出下一个报错，不能解决就寸步难行。学习能力也是一样，有自学能力什么都可以再学，知识总是在进步的。</p>\n\n<h3>感想</h3>\n\n<p>　　我还记得人生第一天上班的心情是激动的，第一次走出学校，了解到一家公司是怎样运作的，一切对我来说都很新鲜。</p>\n\n<p>　　刚开始时每天要回学校住，不过我坚持了一周就受不了了，原因是太远，每天早上挤地铁晚上等公交，来回至少4小时。 于是我果断在附近租了房子，没有别的要求，越近越好！ 按此要求专门请假了一天去看房子，所以最后我只需要漫步7分钟就能到公司。虽然房间很小，但我还是很高兴，因为至少我可以节省更多时间花在学习上了。</p>\n\n<p><img src=\"/room.jpg\" alt=\"room\" style=\"height:300px; width:400px; margin-left:100px;\" /></p>\n\n<p>　　公司氛围很好，大家相处得很融洽，刚来公司时我可以说是除了看过一点书，什么都不会，就连git提交代码我也是一脸懵逼。不过很快我就熟悉了，也学到了一些东西。但每天大家在公司说的很多专业名词，钉钉里的很多讨论，我当时其实还是云里雾里、不明嚼栗的。我觉得我不懂的实在太多，恨不得抓紧时间全部学完，我甚至想过每天就睡在公司还可以不用租房子，我把牙刷毛巾带来，正好厕所也可以洗漱哈哈哈:)</p>\n\n<p>　　我认为我也是<a href=\"http://baike.baidu.com/link?url=e7KzgazS83zXdsvsV7mDkyTLEEQN6aNGzM8BqFoiPHMaIcseSI-b5Ae8YIufBnx6R3eyWx3peCYoBwADNni3-unrWQmA-axIJDfmIhETT7Eb-Y81DzvLyW7m0pOqENxq\">九型性格</a>中偏和平型和完美型的人。我虽然平时话很少，但我看&amp;听得比较多。\n　　我还记得达达说的付出多少就收获多少，记得第一次和海洋哥一起加班到23点，记得凯哥耐心的项目讲解和指导，记得刚上班时丁哥过来和我打招呼（这次某迭代我没能做完深感遗憾），还有和赵伟一起学习公司文化，和磊哥的交流很开心，和Andy一起互相帮助一起打球，和周佳成合作写爬虫，还有每天总是到的最早的杨哥和超超，给我莫大帮助的小虫哥，给我们发橘子吃的朱老师等等……整个开发团队，你们真的很棒！\n　　虽然实习时间不长，但我真的很高兴认识大家。我的生活很单调，每天两点一线，在公司工作让我感到不孤独、有归属感。</p>\n\n<p>　　最近由于学校方面的原因我不得不暂停实习了，说实话这是一个艰难的决定。不远的将来我还希望能和大家共同成长。</p>\n\n<p>　　最后祝 <code>{ 速递易: 越来越好, 各位小伙伴: []  &lt;&lt; &quot;文档自动生成&quot; &lt;&lt; &quot;测试一次通过&quot; &lt;&lt; &quot;代码无bug&quot; &lt;&lt; &quot;老板不改需求&quot; &lt;&lt; &quot;服务没有报警&quot; }</code> \n　　好了似乎可以下班了。</p>\n','　　[\"在写这篇文章之前，我有点犹豫是否应当隐去公司的名字，一番思量之后还是决定不去在意这些细节。如果通篇都用某某来代替，难免写起来枯燥无味，况且，我要写的又不是什么坏事。\"](https://yii.im/posts/some-reflections-on-the-twice-changes-of-sudiyi-wechat-team/)\r\n\r\n　　时间过得飞快，一转眼我都实习了快5个月了。\r\n\r\n### 工作总结\r\n\r\n　　我把目前为止所做的工作分为三个阶段来总结：\r\n   \r\n　　**第一阶段**是学习阶段，作为一个实习生，我的主要任务是学习基础知识，只有把基础的知识掌握好了才能谈其他东西。\r\n  \r\n　　这个阶段我主要是看了三本书，分别是《Programming Ruby》、《ruby基础教程》和《rails tutorial》。\r\n\r\n　　入职前我得到了《Programming Ruby》《ruby基础教程》这两本书，我要求自己在入职之前的9天内把他们啃掉，一共1424页，这对我来说是一个不小的挑战，因为毕竟这是技术书籍，不是看小说，边看还要边理解、学习。刚接触ruby没多久，不懂的东西太多了，于是国庆节7天我就待在家里死磕，每天除了吃饭睡觉都是在学这个东西。最后我也基本完成了这个目标。\r\n\r\n　　通过这次学习，我掌握了很多ruby和rails相关的基础知识。从这个阶段中总结的一个经验就是，学一门语言首要解决的问题是迟迟不肯开始动手，如果只是看书而没有实际的练习就很容易忘掉，最后等书全部看完忘得也差不多了。所以务必要尽快进入实操的阶段，尽量通过解决实际问题来整合知识、巩固知识并加深理解。\r\n\r\n　　之后我做了一个日志练习学会相关的操作，包括状态码计数、相关gem的使用、代码的优化、重构等等，我认为这是一个很好的入门练习，所涉及的知识很全面，基本涵盖了我之前学到的所有基础知识，同时也加深了我的理解。这个练习我重构了三次，可以看到每次都有所进步，最后的效果是明显的，和刚开始写出来的东西相比优化了很多。\r\n\r\n　　这个做完之后我开始写爬虫来抓取某网站的一些数据，然后在后台展示出来。这是我第一次接触爬虫，通过这个练习也学到了很多知识，后台框架先是用了sinatra后用rails，帮助我更加了解了这两个框架。\r\n<h3> </h3>\r\n　　**第二阶段**是接触项目的阶段，基础的东西学完了，我开始接触公司的实际项目，这是我第一次看到真实的项目代码是什么样子。\r\n\r\n　　刚开始是一头雾水的，每块内容单独来看虽然好像看得懂，但我不清楚到底做了些什么，不清楚它们的内在联系或是一些细节的东西。我甚至连把项目跑起来都花了很长的时间。\r\n\r\n　　通过这个阶段，我开始更多地和公司其他人有了交流合作，相对来说公司的项目代码比一些其他的个人写的代码更加规范，更有可读性和学习价值。\r\n\r\n　　我了解了一些开发流程，学会了一些技能和方法（比如git相关操作），第一次接触了前后端分离，也了解了一个公司里面的各个部门的员工到底是在做些什么事情（以前我不知道公司要分产品、测试、前端后端这些部门，学校可不会教这些东西，我以为这些都是一个人做的）。\r\n<h3> </h3>\r\n　　**第三阶段**是参与开发的阶段，正好公司有新项目来了，这次我参与了某系统的开发，从需求分析，出原型，讨论修改，到后端开发，前端开发，联调，测试等，我第一次经历了这个完整的开发流程。\r\n\r\n　　说实话学到的干货不是很多，但是更多的是学到了一个项目从构思到最后完成要经历哪些过程，我觉得这个就和修房子是一样的，先作好图纸规划，打好地基，然后一步步往上建造，最后竣工。除此之外还锻炼了我的团队协作能力、交流沟通能力等，更重要的是解决问题的能力。\r\n\r\n　　我想一个程序员很重要的两个能力就是超强的自学能力和分析解决问题的能力。当我实习完后，可能这些项目若干年后也没用了，就是一堆符号而已，若干年后我自己回去看我写的这些代码可能也看不懂了，但是解决问题的能力是很重要的，这个报错完了还会出下一个报错，不能解决就寸步难行。学习能力也是一样，有自学能力什么都可以再学，知识总是在进步的。\r\n\r\n### 感想\r\n\r\n　　我还记得人生第一天上班的心情是激动的，第一次走出学校，了解到一家公司是怎样运作的，一切对我来说都很新鲜。\r\n\r\n　　刚开始时每天要回学校住，不过我坚持了一周就受不了了，原因是太远，每天早上挤地铁晚上等公交，来回至少4小时。 于是我果断在附近租了房子，没有别的要求，越近越好！ 按此要求专门请假了一天去看房子，所以最后我只需要漫步7分钟就能到公司。虽然房间很小，但我还是很高兴，因为至少我可以节省更多时间花在学习上了。\r\n\r\n<img src=\"/room.jpg\" alt=\"room\" style=\"height:300px; width:400px; margin-left:100px;\" />\r\n\r\n　　公司氛围很好，大家相处得很融洽，刚来公司时我可以说是除了看过一点书，什么都不会，就连git提交代码我也是一脸懵逼。不过很快我就熟悉了，也学到了一些东西。但每天大家在公司说的很多专业名词，钉钉里的很多讨论，我当时其实还是云里雾里、不明嚼栗的。我觉得我不懂的实在太多，恨不得抓紧时间全部学完，我甚至想过每天就睡在公司还可以不用租房子，我把牙刷毛巾带来，正好厕所也可以洗漱哈哈哈:)\r\n\r\n　　我认为我也是[九型性格](http://baike.baidu.com/link?url=e7KzgazS83zXdsvsV7mDkyTLEEQN6aNGzM8BqFoiPHMaIcseSI-b5Ae8YIufBnx6R3eyWx3peCYoBwADNni3-unrWQmA-axIJDfmIhETT7Eb-Y81DzvLyW7m0pOqENxq)中偏和平型和完美型的人。我虽然平时话很少，但我看&听得比较多。\r\n　　我还记得达达说的付出多少就收获多少，记得第一次和海洋哥一起加班到23点，记得凯哥耐心的项目讲解和指导，记得刚上班时丁哥过来和我打招呼（这次某迭代我没能做完深感遗憾），还有和赵伟一起学习公司文化，和磊哥的交流很开心，和Andy一起互相帮助一起打球，和周佳成合作写爬虫，还有每天总是到的最早的杨哥和超超，给我莫大帮助的小虫哥，给我们发橘子吃的朱老师等等……整个开发团队，你们真的很棒！\r\n　　虽然实习时间不长，但我真的很高兴认识大家。我的生活很单调，每天两点一线，在公司工作让我感到不孤独、有归属感。\r\n\r\n　　最近由于学校方面的原因我不得不暂停实习了，说实话这是一个艰难的决定。不远的将来我还希望能和大家共同成长。\r\n\r\n　　最后祝 `{ 速递易: 越来越好, 各位小伙伴: []  << \"文档自动生成\" << \"测试一次通过\" << \"代码无bug\" << \"老板不改需求\" << \"服务没有报警\" }` \r\n　　好了似乎可以下班了。','2017-02','^^总结','2017-02-28 00:00:00','2017-02-28 00:00:00'),(3,'Git 常用操作总结','<h2>git操作与程序员的日常工作紧密相关，以下列出一些常用的操作</h2>\n\n<p>查看远程分支 <code>git branch -a</code></p>\n\n<p>更新远程分支 <code>git remote update</code></p>\n\n<p>删除远程分支 <code>git push origin --delete &lt;branchName&gt;</code> 或 <code>git push origin :&lt;branchname&gt;</code></p>\n\n<p>重命名本地分支　<code>git branch -m &lt;oldname&gt; &lt;newname&gt;</code></p>\n\n<p>重命名远程分支</p>\n\n<p>在git中重命名远程分支，其实就是先删除远程分支，然后重命名本地分支，再重新提交一个远程分支。</p>\n\n<p>创建并切换分支　<code>git checkout -b newbranch</code>　等价于：</p>\n\n<p><code>\ngit branch newbranch;<br/>\ngit checkout newbranch\n</code></p>\n\n<p>链接远程仓库　<code>git remote add origin &lt;server&gt;</code></p>\n\n<p>恢复到指定的commit <code>git reset --hard resetVersionHash</code></p>\n\n<h3>git pull时出现冲突，如何放弃本地修改，强制pull远程代码到本地？</h3>\n\n<p><code>\ngit fetch origin 　# 获取最新版本 <br/>\ngit reset --hard origin/master  # 把HEAD指向最新下载的版本\n</code></p>\n\n<h3> </h3>\n\n<p>删除暂存区或分支上的文件，但保留本地文件 <code>git rm --cached file_path</code></p>\n\n<p>修改提交信息(commit message) <code>git commit --amend -m &quot;new-commit-message&quot;</code></p>\n\n<p>撤销git add(还没有git commit之前) <code>git reset &lt;filename&gt;</code>  </p>\n\n<h3>切换分支时保存已修改的代码</h3>\n\n<p>假设有两个分支：1和2。我在1上开发了一半，忽然需要切换到2去改bug。\n这种情况有两个方法：</p>\n\n<p>1.及时commit代码</p>\n\n<p>在分支1上把已经开发完成的部分代码commit，不push，然后切换到分支2修改代码，做完了commit，所有分支互不影响，这是一个理想的方法。</p>\n\n<p>2.使用git stash</p>\n\n<p>在分支1上：<code>git stash</code></p>\n\n<p>或者 <code>git stash save “修改的信息&quot;</code></p>\n\n<p>然后切到分支2修改代码完成，再回到分支1时，使用：<code>git stash pop</code></p>\n\n<p>或者\n<code>\ngit stash list<br/>\ngit stash apply stash@{0}\n</code>\n就可以回到保存的版本了。</p>\n\n<h3>解决每次git提交都要输入用户名和密码</h3>\n\n<p>1.查看远程仓库： <code>git remote -v</code></p>\n\n<p>2.此时仓库链接多半是http链接，将其删除： <code>git remote remove origin</code></p>\n\n<p>3.重新用ssh链接远程仓库： <code>git remote add origin &lt;address&gt;</code>  (这个地址应类似git@github.com:xxx.git）</p>\n\n<p><br/>\n<h3>参考文章</h3></p>\n\n<p><a href=\"http://zengrong.net/post/1746.htm\">http://zengrong.net/post/1746.htm</a></p>\n\n<p><a href=\"http://www.cnblogs.com/deepnighttwo/archive/2011/06/18/2084438.html\">http://www.cnblogs.com/deepnighttwo/archive/2011/06/18/2084438.html</a></p>\n\n<p><a href=\"http://www.tonitech.com/2344.html\">http://www.tonitech.com/2344.html</a></p>\n\n<p><a href=\"http://gitref.org/\">http://gitref.org/</a></p>\n\n<p><a href=\"http://www.oschina.net/news/68437/seven-git-hacks-you-just-cannot-ignore\">http://www.oschina.net/news/68437/seven-git-hacks-you-just-cannot-ignore</a></p>\n','<h2>git操作与程序员的日常工作紧密相关，以下列出一些常用的操作</h2>\r\n\r\n查看远程分支 `git branch -a`\r\n\r\n更新远程分支 `git remote update`\r\n\r\n删除远程分支 `git push origin --delete <branchName>` 或 `git push origin :<branchname>`\r\n\r\n重命名本地分支　`git branch -m <oldname> <newname>`\r\n\r\n重命名远程分支\r\n\r\n在git中重命名远程分支，其实就是先删除远程分支，然后重命名本地分支，再重新提交一个远程分支。\r\n\r\n创建并切换分支　`git checkout -b newbranch`　等价于：\r\n\r\n<code>\r\ngit branch newbranch;<br/>\r\ngit checkout newbranch\r\n</code>\r\n\r\n链接远程仓库　`git remote add origin <server>`\r\n\r\n恢复到指定的commit `git reset --hard resetVersionHash`\r\n\r\n<h3>git pull时出现冲突，如何放弃本地修改，强制pull远程代码到本地？</h3>\r\n<code>\r\ngit fetch origin 　# 获取最新版本 <br/>\r\ngit reset --hard origin/master  # 把HEAD指向最新下载的版本\r\n</code>\r\n\r\n<h3> </h3>\r\n删除暂存区或分支上的文件，但保留本地文件 `git rm --cached file_path`\r\n\r\n修改提交信息(commit message) `git commit --amend -m \"new-commit-message\"`\r\n\r\n撤销git add(还没有git commit之前) `git reset <filename>`  \r\n\r\n\r\n<h3>切换分支时保存已修改的代码</h3>\r\n\r\n假设有两个分支：1和2。我在1上开发了一半，忽然需要切换到2去改bug。\r\n这种情况有两个方法：\r\n\r\n1.及时commit代码\r\n\r\n在分支1上把已经开发完成的部分代码commit，不push，然后切换到分支2修改代码，做完了commit，所有分支互不影响，这是一个理想的方法。\r\n \r\n2.使用git stash\r\n\r\n在分支1上：`git stash`\r\n\r\n或者 `git stash save “修改的信息\"`\r\n\r\n然后切到分支2修改代码完成，再回到分支1时，使用：`git stash pop`\r\n\r\n或者\r\n<code>\r\ngit stash list<br/>\r\ngit stash apply stash@{0}\r\n</code>\r\n就可以回到保存的版本了。\r\n\r\n<h3>解决每次git提交都要输入用户名和密码</h3>\r\n\r\n1.查看远程仓库： `git remote -v`\r\n\r\n2.此时仓库链接多半是http链接，将其删除： `git remote remove origin`\r\n\r\n3.重新用ssh链接远程仓库： `git remote add origin <address>`  (这个地址应类似git@github.com:xxx.git）\r\n\r\n\r\n<br/>\r\n<h3>参考文章</h3>\r\n\r\n[http://zengrong.net/post/1746.htm](http://zengrong.net/post/1746.htm)\r\n\r\n[http://www.cnblogs.com/deepnighttwo/archive/2011/06/18/2084438.html](http://www.cnblogs.com/deepnighttwo/archive/2011/06/18/2084438.html)\r\n\r\n[http://www.tonitech.com/2344.html](http://www.tonitech.com/2344.html)\r\n\r\n[http://gitref.org/](http://gitref.org/)\r\n\r\n[http://www.oschina.net/news/68437/seven-git-hacks-you-just-cannot-ignore](http://www.oschina.net/news/68437/seven-git-hacks-you-just-cannot-ignore)\r\n\r\n','2016-12','^^总结^^Git','2016-12-04 00:00:00','2016-12-27 00:00:00'),(4,'实例方法与类方法','<p>实例方法与类方法有什么区别？model里的方法在controller里面怎么调用？这些很基础的问题是必须要搞清楚的。  </p>\n\n<pre><code>class Object\n  def abc  \n    p &quot;instance abc&quot; \n  end \n\n  def self.abc  \n    p &quot;class abc&quot;  \n  end  \nend  \n\nobj = Object.new \n\nobj.abc  # instance abc  \nObject.abc  # class abc\n</code></pre>\n\n<p>类方法只有类本身可以调用，实例方法是类的一个实例调用。</p>\n\n<p>在ruby中，类方法是一种特殊的单例方法(singleton method)</p>\n\n<pre><code>class C  　 # 定义类C\n  def a_method    # 定义实例方法 a_method\n    puts &quot;C#a_method&quot;  　　　\n  end  \n\n  def self.a_class_method   # 定义类方法 a_class_method \n    puts &quot;C#a_class_method&quot;  \n  end  \nend  \n\nclass D &lt; C  # 定义类D，继承自类C      \nend  \n\nobj = D.new  # 创建类D的实例对象obj\nobj.a_method  # 实例方法\nD.a_class_method   # 类方法\n\n\nclass Object  \n  def eigenclass  \n    class &lt;&lt; self  \n      self \n    end  \n  end  \nend  \n\nclass &lt;&lt; obj   \n  def a_singleton_method   # 给obj定义单例方法 a_singleton_method \n    puts &#39;obj#a_singleton_method&#39;  \n  end \nend  \n\nputs obj.a_singleton_method  \n</code></pre>\n\n<h3>参考资料</h3>\n\n<p>《ruby元编程》 </p>\n','实例方法与类方法有什么区别？model里的方法在controller里面怎么调用？这些很基础的问题是必须要搞清楚的。  \r\n\r\n    class Object\r\n      def abc  \r\n        p \"instance abc\" \r\n      end \r\n     \r\n      def self.abc  \r\n        p \"class abc\"  \r\n      end  \r\n    end  \r\n  \r\n    obj = Object.new \r\n  \r\n    obj.abc  # instance abc  \r\n    Object.abc  # class abc\r\n\r\n类方法只有类本身可以调用，实例方法是类的一个实例调用。\r\n\r\n在ruby中，类方法是一种特殊的单例方法(singleton method)\r\n\r\n    class C  　 # 定义类C\r\n      def a_method    # 定义实例方法 a_method\r\n        puts \"C#a_method\"  　　　\r\n      end  \r\n      \r\n      def self.a_class_method   # 定义类方法 a_class_method \r\n        puts \"C#a_class_method\"  \r\n      end  \r\n    end  \r\n    \r\n    class D < C  # 定义类D，继承自类C      \r\n    end  \r\n      \r\n    obj = D.new  # 创建类D的实例对象obj\r\n    obj.a_method  # 实例方法\r\n    D.a_class_method   # 类方法\r\n \r\n \r\n    class Object  \r\n      def eigenclass  \r\n        class << self  \r\n          self \r\n        end  \r\n      end  \r\n    end  \r\n      \r\n    class << obj   \r\n      def a_singleton_method   # 给obj定义单例方法 a_singleton_method \r\n        puts \'obj#a_singleton_method\'  \r\n      end \r\n    end  \r\n      \r\n    puts obj.a_singleton_method  \r\n\r\n\r\n<h3>参考资料</h3>\r\n\r\n《ruby元编程》 ','2016-11','^^Ruby','2016-11-28 00:00:00','2016-11-28 00:00:00'),(5,'Terminal 功夫——方便开发者的实用技巧','<h2>前言</h2>\n\n<p>这是我在过去几年中提炼出的一些方便你编程的小技巧和提示。在这篇文章中，你将学到如何更有效率地做你每天做的事情。 \n 　</p>\n\n<h2>快速搜索命令行历史记录</h2>\n\n<p>我真的很难记住一些命令，特别是那些有一大堆参数的。而且有时候更烦，你不得不停下来然后又去google你两个小时之前引用的某个命令。不用担心，<code>reverse-i-search</code>可以拯救你。<strong>打开你的终端，按下<code>Ctrl + R</code></strong>。输入你最近使用的命令的前几个字符，它会显示出符合你要查询的命令。如果有多个匹配的命令，重复按<code>Ctrl + R</code>直到找到你想要的然后按<code>Ctrl + E</code>选择即可。<br>\n你也可以输入<code>history</code>就可以显示出你之前执行过的命令列表。\n　</p>\n\n<h2>缩短退格时间</h2>\n\n<p>你是否遇到过很长的查询，比如跨了4行，然后你想跳到前边去做一些修改，或者是你写了很长的命令，跨了4行，结果发现只是在最开始的地方有点错？这时候你可能要按箭头，然后一个一个字符地把光标移到开头去。但你可以使用快捷方法，这些方法可以节省你很多按方向键和空格键的时间。</p>\n\n<p><code>Ctrl + K</code> - 删除光标右边的所有内容</p>\n\n<p><code>Ctrl + W</code> - 删除光标左右的所有内容（一次一个单词）</p>\n\n<p><code>Ctrl + A</code> - 跳到行首</p>\n\n<p><code>Ctrl + E</code> - 跳到行尾\n　</p>\n\n<h2>在 rails console 中用 _ 访问最后一个表达式</h2>\n\n<p>这是另一个我经常犯的错误：在 rails 控制台中查询一个 ActiveRecord model，忘了把结果保存在一个变量里，然后按<code>↑</code>加上一个变量再做一遍。</p>\n\n<p>很幸运比我聪明的人也有这个问题，实际上他们已经解决了。每次你在 console 里面执行一个命令或者是功能，其返回值都会被保存在一个叫做<code>_</code>的变量里（对，就是一个下划线）</p>\n\n<p>所以，比如你在 console 里面执行了<code>User.first(5)</code>。你得到了前5个 users 但是你忘了存在一个变量里。这时你只需要<code>_.first.name</code>或者更好的是你可以 <code>users = _</code>. 现在变量  users 就等于<code>User.first(5)</code>的返回值了。\n　</p>\n\n<h2>找到任何URL的 Controller 和 Action</h2>\n\n<p>这个也超有用，尤其是当你的 routes 文件达到了500行，你有5个不同的 namespaces，还有一堆自定义的 actions 时。你有个URL，你想知道它执行的是哪个 Controller 和 Action。常见的方法是打开 routes 文件然后扫描整个文件去查找。或者你会用 <a href=\"https://github.com/dejan/rails_panel\">RailsPanel</a> 来查看 Controller 和 Action。但这都要耗些时间。</p>\n\n<p>如果你想要秒秒钟搞定这件事，在 rails console 里面用这个命令：</p>\n\n<p><code>Rails.application.routes.recognize_path &quot;http://localhost:3000/users/11&quot;</code></p>\n\n<p>Ps: 当用在不是GET的action上的时候要小心，可能会返回正确的controller，错误的action</p>\n\n<h2>在 sandbox 里面玩</h2>\n\n<p>你想在 console 中弄乱一些值然后看看程序怎么反应，但是你又不想破坏你的原始数据库？不用害怕，rails console 里面有一个内置的选项为此而设。用以下命令启动 rails console</p>\n\n<p><code>rails console --sandbox</code></p>\n\n<p>在这个模式下 console 被包装在数据库事务中启动。当你退出回话后，事务将回滚。所以你可以随意增删改数据，当你退出 console 时数据库会被恢复到原始状态。但要小心在沙箱里面运行事务因为并非所有数据库都可以处理嵌套事务。\n 　</p>\n\n<h2>重新加载控制台</h2>\n\n<p>你在 console 里面试了一些东西，不起作用。然后你要改一下你的代码再试一次，这时候不用关掉 console 又重新启动，只需\n<code>reload!</code>\n　</p>\n\n<h2>去除ri和rdoc</h2>\n\n<p><img src=\"http://www.rubyonrails365.com/images/2015/june/xkcd_bundle_installing-58173d59.png\" alt=\"bundle installing\"></p>\n\n<p>你在 Github 上看到一个很好的项目，你立即把它 clone 下来然后<code>bundle install</code>。然后...你花了30分钟来下载所有的 gems，而这其中一半的时间都花在了下载 RDoc 和 ri 文件上了，你可能从来不用这些，甚至你可能根本不知道这是什么鬼。可以说只要你联网了你就不是必须要用他们，但是当你 bundle 的时候会自动下载。这里有两个方法来处理：</p>\n\n<p>第一，如果你是安装单个 gem，使用</p>\n\n<p><code>gem install rails --no-ri --no-rdoc</code></p>\n\n<p>这样就告诉 bundler 不要下载 RDoc 和集成 ri 文件。这样就节省了很多时间和空间。</p>\n\n<p>但上面这个方法只是在你安装单个gem的时候有用。如果你想让安装所有gem的时候都默认这样做的话：</p>\n\n<p>步骤1. 在home目录下创建一个文件命名为<code>.gemrc</code></p>\n\n<p><code>cd ~; touch .gemrc;</code></p>\n\n<p>步骤2. 在你的编辑器里面打开这个文件</p>\n\n<p><code>subl ~/.gemrc  # 用你的编辑器打开这个文件</code></p>\n\n<p>步骤3. 将以下代码粘贴进去即可</p>\n\n<pre><code>gem: --no-ri --no-rdoc\ninstall: --no-rdoc --no-ri\nupdate:  --no-rdoc --no-ri\n</code></pre>\n\n<p>我们还可以更深入一点。很多大中型项目的gem平均要跑50秒，这还不包括解决每个gem的依赖。例如<a href=\"https://github.com/discourse/discourse\">Discourse</a>这个项目有大概<a href=\"https://github.com/discourse/discourse/blob/master/Gemfile\">150个gems</a></p>\n\n<p>我们可以通过并发安装gem让这变得更快，确保充分利用你的网络带宽处理能力。我们通过给bundler加上<code>--jobs</code>这个参数来完成。</p>\n\n<p><code>bundle install discourse --jobs=4</code></p>\n\n<p>运行这个命令你会看到gems的安装快得飞起。然而这不是任何时候都适用的，有时候会出现死锁或者冲突。解决方法只需运行：</p>\n\n<p><code>bundle install discourse --jobs=1</code></p>\n\n<p>这样就设置回了默认的情况。\n　</p>\n\n<h2>看一下gem内部</h2>\n\n<p>或许因为你的好奇心，你想看一下一个特定的功能是怎么执行的，想看一下你正在使用的一个gem的源代码。是的，你可以每次去google github 里面的项目然后在那里看。但是其实可以不用这样。只需要</p>\n\n<p><code>EDITOR=subl bundle open devise</code></p>\n\n<p><code>subl</code>这里是你的编辑器，<code>devise</code>是你的gem名字。这里我们打开了devise这个gem。这样做的好处是它可以打开你正在使用的gem的版本。</p>\n\n<p>然后你可以在项目里面做你想做的事情，你可以修改代码来理解它做了什么事，可以修改下function甚至是增加functions。当你看完了代码之后，你可以用以下命令使它回到初始状态</p>\n\n<p><code>gem pristine devise</code>\n　</p>\n\n<h2>在你的代码里面写注释</h2>\n\n<p>当你写代码的时候，你可能想在代码里面快速地做一些笔记。或许你可能想写下“想要重构”之类的。不用切换到其他地方去做笔记，rails提供了一个东西，你只需要在你的程序里面使用 <code>#TODO</code>. </p>\n\n<pre><code>#TODO make this a one line function.\ndef new\nend\n</code></pre>\n\n<p>之后你可以在console里面输入以下命令来查看你的所有笔记：\n<code>bundle exec rake notes:todo</code></p>\n\n<p>但这样久了之后你可能会发现你有很多 todos，你可能想要描述得更加具体，你可以做一些自定义的修改，比如：</p>\n\n<pre><code>#REFACTOR make this a one line function.\ndef new\nend\n</code></pre>\n\n<p>然后这样去查找：\n<code>bundle exec rake notes:custom ANNOTATION=REFACTOR</code>\n 　</p>\n\n<h2>找到任何方法的源地址</h2>\n\n<p>有时你在 console 中使用一个方法，尤其是你引用的 gem 包里面定义的方法，你想看看它的源代码。方法经常在不同的文件之间有相同的名称，你不确定是调用的哪个，或者说想查看这个方法在哪里定义的。这时候找到源代码的位置的最简单方法是：</p>\n\n<pre><code>user.method(:password=).source_location \n=&gt; #[&quot;/Users/ror365/.rbenv/versions/2.1.5/lib/ruby/gems/2.1.0/gems/activemodel-4.2.0\n/lib/active_model/secure_password.rb&quot;, 119]\n</code></pre>\n\n<p>返回的是确切的文件路径和相应的行号，然后你就可以按照这个去查找啦。\n　</p>\n\n<h2>列出所有的 rake 任务</h2>\n\n<p>如果你有一个较大的应用程序，你写了多个 rake 任务，然后 rails 本身也内置了一些rake任务，这时候你可能很难记住或者找到他们。最简单快速的方法来找到 rake 任务，运行：</p>\n\n<p><code>bundle exec rake -T</code></p>\n\n<p><code>-T</code>这个参数告诉 rake 列出在这个应用程序里面找到的所有 rake 任务，而且可以打印出这个任务的描述。\n　</p>\n\n<h2>清理一些磁盘空间</h2>\n\n<p>我的一个同事，他的 Macbook Pro 有120个G的硬盘。时间长了就占满了，然后他想找一些东西来删掉。我碰巧有次看到他在做这个事，然后就问他：“你清理你的rails logs了吗？”他说没有，然后他去看log，他本地的 development log 已经占用了2G的空间。看来从他买了这电脑就一直没清理过。</p>\n\n<p>日复一日地开发一个应用程序，你可能没注意到你所做的每个请求都写在了开发日志(development log)里面。这可能并不是很大，但是它会快速地增加。不用手动去删除它，你可以运行这个专门为此设计的命令：</p>\n\n<p><code>bundle exec rake log:clear</code></p>\n\n<p>这会清理你的日志从而你可以获得一些硬盘空间。</p>\n\n<h2>找出所有过时的gems</h2>\n\n<p>开源世界，变化万千。如果你有一堆gems，你可能经常需要更新他们。然而运行<code>bundle update</code>命令有点危险，因为它会破坏一些东西。我建议在你的项目里先执行</p>\n\n<p><code>bundle outdated</code></p>\n\n<p>这样会列出所有需要更新的gems。然后你可以根据这个去bundle update某个单独的gem.\n　</p>\n\n<h2>总结</h2>\n\n<p>一个人可以知道的小技巧是无限的，知道这些可能并不会让你成为一个更好的开发者，而且一个知道这些小提示和技巧的人也不见得比你厉害，虽然往往会有这样的错觉。这些小技巧可以使你更高效一点，没有别的。</p>\n\n<p>（<a href=\"http://www.rubyonrails365.com/tips-and-tricks/\">原文</a>翻译时有改动）</p>\n\n<h6>　</h6>\n','## 前言\r\n  这是我在过去几年中提炼出的一些方便你编程的小技巧和提示。在这篇文章中，你将学到如何更有效率地做你每天做的事情。 \r\n 　\r\n## 快速搜索命令行历史记录\r\n\r\n  我真的很难记住一些命令，特别是那些有一大堆参数的。而且有时候更烦，你不得不停下来然后又去google你两个小时之前引用的某个命令。不用担心，`reverse-i-search`可以拯救你。**打开你的终端，按下`Ctrl + R`**。输入你最近使用的命令的前几个字符，它会显示出符合你要查询的命令。如果有多个匹配的命令，重复按`Ctrl + R `直到找到你想要的然后按`Ctrl + E`选择即可。  \r\n你也可以输入`history`就可以显示出你之前执行过的命令列表。\r\n　\r\n## 缩短退格时间\r\n\r\n  你是否遇到过很长的查询，比如跨了4行，然后你想跳到前边去做一些修改，或者是你写了很长的命令，跨了4行，结果发现只是在最开始的地方有点错？这时候你可能要按箭头，然后一个一个字符地把光标移到开头去。但你可以使用快捷方法，这些方法可以节省你很多按方向键和空格键的时间。\r\n\r\n`Ctrl + K` - 删除光标右边的所有内容\r\n\r\n`Ctrl + W` - 删除光标左右的所有内容（一次一个单词）\r\n\r\n`Ctrl + A` - 跳到行首\r\n\r\n`Ctrl + E` - 跳到行尾\r\n　\r\n## 在 rails console 中用 _ 访问最后一个表达式\r\n\r\n这是另一个我经常犯的错误：在 rails 控制台中查询一个 ActiveRecord model，忘了把结果保存在一个变量里，然后按`↑`加上一个变量再做一遍。\r\n\r\n很幸运比我聪明的人也有这个问题，实际上他们已经解决了。每次你在 console 里面执行一个命令或者是功能，其返回值都会被保存在一个叫做`_`的变量里（对，就是一个下划线）\r\n\r\n所以，比如你在 console 里面执行了`User.first(5)`。你得到了前5个 users 但是你忘了存在一个变量里。这时你只需要`_.first.name`或者更好的是你可以 `users = _`. 现在变量  users 就等于`User.first(5)`的返回值了。\r\n　\r\n## 找到任何URL的 Controller 和 Action\r\n\r\n这个也超有用，尤其是当你的 routes 文件达到了500行，你有5个不同的 namespaces，还有一堆自定义的 actions 时。你有个URL，你想知道它执行的是哪个 Controller 和 Action。常见的方法是打开 routes 文件然后扫描整个文件去查找。或者你会用 [RailsPanel] (https://github.com/dejan/rails_panel) 来查看 Controller 和 Action。但这都要耗些时间。\r\n\r\n如果你想要秒秒钟搞定这件事，在 rails console 里面用这个命令：\r\n\r\n`Rails.application.routes.recognize_path \"http://localhost:3000/users/11\"`\r\n\r\nPs: 当用在不是GET的action上的时候要小心，可能会返回正确的controller，错误的action\r\n\r\n## 在 sandbox 里面玩\r\n\r\n你想在 console 中弄乱一些值然后看看程序怎么反应，但是你又不想破坏你的原始数据库？不用害怕，rails console 里面有一个内置的选项为此而设。用以下命令启动 rails console\r\n\r\n`rails console --sandbox`\r\n\r\n在这个模式下 console 被包装在数据库事务中启动。当你退出回话后，事务将回滚。所以你可以随意增删改数据，当你退出 console 时数据库会被恢复到原始状态。但要小心在沙箱里面运行事务因为并非所有数据库都可以处理嵌套事务。\r\n 　\r\n## 重新加载控制台\r\n\r\n你在 console 里面试了一些东西，不起作用。然后你要改一下你的代码再试一次，这时候不用关掉 console 又重新启动，只需\r\n`reload!`\r\n　\r\n## 去除ri和rdoc\r\n\r\n![bundle installing](http://www.rubyonrails365.com/images/2015/june/xkcd_bundle_installing-58173d59.png)\r\n\r\n你在 Github 上看到一个很好的项目，你立即把它 clone 下来然后`bundle install`。然后...你花了30分钟来下载所有的 gems，而这其中一半的时间都花在了下载 RDoc 和 ri 文件上了，你可能从来不用这些，甚至你可能根本不知道这是什么鬼。可以说只要你联网了你就不是必须要用他们，但是当你 bundle 的时候会自动下载。这里有两个方法来处理：\r\n\r\n第一，如果你是安装单个 gem，使用\r\n\r\n`gem install rails --no-ri --no-rdoc`\r\n\r\n这样就告诉 bundler 不要下载 RDoc 和集成 ri 文件。这样就节省了很多时间和空间。\r\n\r\n但上面这个方法只是在你安装单个gem的时候有用。如果你想让安装所有gem的时候都默认这样做的话：\r\n\r\n步骤1. 在home目录下创建一个文件命名为`.gemrc `\r\n\r\n`cd ~; touch .gemrc;`\r\n\r\n步骤2. 在你的编辑器里面打开这个文件\r\n\r\n`subl ~/.gemrc  # 用你的编辑器打开这个文件`\r\n\r\n步骤3. 将以下代码粘贴进去即可\r\n\r\n    gem: --no-ri --no-rdoc\r\n    install: --no-rdoc --no-ri\r\n    update:  --no-rdoc --no-ri\r\n\r\n我们还可以更深入一点。很多大中型项目的gem平均要跑50秒，这还不包括解决每个gem的依赖。例如[Discourse] (https://github.com/discourse/discourse)这个项目有大概[150个gems] (https://github.com/discourse/discourse/blob/master/Gemfile)\r\n\r\n我们可以通过并发安装gem让这变得更快，确保充分利用你的网络带宽处理能力。我们通过给bundler加上`--jobs`这个参数来完成。\r\n\r\n`bundle install discourse --jobs=4`\r\n\r\n运行这个命令你会看到gems的安装快得飞起。然而这不是任何时候都适用的，有时候会出现死锁或者冲突。解决方法只需运行：\r\n\r\n`bundle install discourse --jobs=1`\r\n\r\n这样就设置回了默认的情况。\r\n　\r\n## 看一下gem内部\r\n\r\n或许因为你的好奇心，你想看一下一个特定的功能是怎么执行的，想看一下你正在使用的一个gem的源代码。是的，你可以每次去google github 里面的项目然后在那里看。但是其实可以不用这样。只需要\r\n\r\n`EDITOR=subl bundle open devise`\r\n\r\n`subl`这里是你的编辑器，`devise`是你的gem名字。这里我们打开了devise这个gem。这样做的好处是它可以打开你正在使用的gem的版本。\r\n\r\n然后你可以在项目里面做你想做的事情，你可以修改代码来理解它做了什么事，可以修改下function甚至是增加functions。当你看完了代码之后，你可以用以下命令使它回到初始状态\r\n\r\n`gem pristine devise`\r\n　\r\n## 在你的代码里面写注释\r\n\r\n当你写代码的时候，你可能想在代码里面快速地做一些笔记。或许你可能想写下“想要重构”之类的。不用切换到其他地方去做笔记，rails提供了一个东西，你只需要在你的程序里面使用 `#TODO`. \r\n\r\n    #TODO make this a one line function.\r\n    def new\r\n    end\r\n\r\n之后你可以在console里面输入以下命令来查看你的所有笔记：\r\n`bundle exec rake notes:todo`\r\n\r\n但这样久了之后你可能会发现你有很多 todos，你可能想要描述得更加具体，你可以做一些自定义的修改，比如：\r\n\r\n    #REFACTOR make this a one line function.\r\n    def new\r\n    end\r\n\r\n然后这样去查找：\r\n`bundle exec rake notes:custom ANNOTATION=REFACTOR`\r\n 　\r\n## 找到任何方法的源地址\r\n\r\n有时你在 console 中使用一个方法，尤其是你引用的 gem 包里面定义的方法，你想看看它的源代码。方法经常在不同的文件之间有相同的名称，你不确定是调用的哪个，或者说想查看这个方法在哪里定义的。这时候找到源代码的位置的最简单方法是：\r\n\r\n    user.method(:password=).source_location \r\n    => #[\"/Users/ror365/.rbenv/versions/2.1.5/lib/ruby/gems/2.1.0/gems/activemodel-4.2.0\r\n    /lib/active_model/secure_password.rb\", 119]\r\n\r\n返回的是确切的文件路径和相应的行号，然后你就可以按照这个去查找啦。\r\n　\r\n## 列出所有的 rake 任务\r\n\r\n如果你有一个较大的应用程序，你写了多个 rake 任务，然后 rails 本身也内置了一些rake任务，这时候你可能很难记住或者找到他们。最简单快速的方法来找到 rake 任务，运行：\r\n\r\n`bundle exec rake -T `\r\n\r\n`-T`这个参数告诉 rake 列出在这个应用程序里面找到的所有 rake 任务，而且可以打印出这个任务的描述。\r\n　\r\n## 清理一些磁盘空间\r\n\r\n我的一个同事，他的 Macbook Pro 有120个G的硬盘。时间长了就占满了，然后他想找一些东西来删掉。我碰巧有次看到他在做这个事，然后就问他：“你清理你的rails logs了吗？”他说没有，然后他去看log，他本地的 development log 已经占用了2G的空间。看来从他买了这电脑就一直没清理过。\r\n\r\n日复一日地开发一个应用程序，你可能没注意到你所做的每个请求都写在了开发日志(development log)里面。这可能并不是很大，但是它会快速地增加。不用手动去删除它，你可以运行这个专门为此设计的命令：\r\n\r\n`bundle exec rake log:clear`\r\n\r\n这会清理你的日志从而你可以获得一些硬盘空间。\r\n\r\n## 找出所有过时的gems\r\n\r\n开源世界，变化万千。如果你有一堆gems，你可能经常需要更新他们。然而运行`bundle update`命令有点危险，因为它会破坏一些东西。我建议在你的项目里先执行\r\n\r\n`bundle outdated`\r\n\r\n这样会列出所有需要更新的gems。然后你可以根据这个去bundle update某个单独的gem.\r\n　\r\n## 总结\r\n\r\n一个人可以知道的小技巧是无限的，知道这些可能并不会让你成为一个更好的开发者，而且一个知道这些小提示和技巧的人也不见得比你厉害，虽然往往会有这样的错觉。这些小技巧可以使你更高效一点，没有别的。\r\n\r\n（[原文] (http://www.rubyonrails365.com/tips-and-tricks/)翻译时有改动）\r\n###### 　','2016-12','^^翻译','2016-12-02 00:00:00','2016-12-02 00:00:00'),(6,'Common Rails Idioms that Kill Database Performance','<h1>前言</h1>\n\n<p>关于数据库查询，让我们来看一看那些让你的程序停滞不前的罪魁祸首。</p>\n\n<p>我还记得我第一次看到rails的ActiveRecord，那是一次启发。那是2005年的时候，当时我在给一个PHP程序写SQL语句。突然间，写数据库从单调繁杂的零星工作变得简单且有趣了。</p>\n\n<p>...然后我就开始关注到性能(performance)的问题。</p>\n\n<p>ActiveRecord它本身并不慢。我停止把注意力花在那些实际正在运行的查询上。结果是，当数据量变得庞大后，在rails的增删查改操作中一些最符合语言习惯的数据库查询就十分低效。</p>\n\n<p>这篇文章我们将讨论这其中的三个罪魁祸首。但首先，让我们先聊聊怎么知道你的数据库查询是否高效。</p>\n\n<h5>　　</h5>\n\n<h2>测量性能</h2>\n\n<p>如果你数据量足够小的话每个数据库查询都是高效的。所以为了真正地感知效率，我们需要以一个生产级别的数据库为基准。在我们的示例中，我们将使用一个有大约22000条记录的叫做faults的表。</p>\n\n<p>我们会用到postgres。在postgres中，衡量性能的方法是使用explain。比如：</p>\n\n<pre><code># explain (analyze) select * from faults where id = 1;\n                                     QUERY PLAN\n----------------------------------------------------------------------------------------\n Index Scan using faults_pkey on faults  (cost=0.29..8.30 rows=1 width=1855) (actual \ntime=0.556..0.556 rows=0 loops=1)\n   Index Cond: (id = 1)\n Total runtime: 0.626 ms\n</code></pre>\n\n<p>这显示出了执行这次查询的预计花费 (cost=0.29..8.30 rows=1 width=1855) 和执行的实际时间(actual time=0.556..0.556 rows=0 loops=1)。</p>\n\n<p>如果你想要一个更易读的格式，你可以让postgres以YAML文件打印出来。</p>\n\n<pre><code># explain (analyze, format yaml) select * from faults where id = 1;\n              QUERY PLAN\n--------------------------------------\n - Plan:                             +\n     Node Type: &quot;Index Scan&quot;         +\n     Scan Direction: &quot;Forward&quot;       +\n     Index Name: &quot;faults_pkey&quot;       +\n     Relation Name: &quot;faults&quot;         +\n     Alias: &quot;faults&quot;                 +\n     Startup Cost: 0.29              +\n     Total Cost: 8.30                +\n     Plan Rows: 1                    +\n     Plan Width: 1855                +\n     Actual Startup Time: 0.008      +\n     Actual Total Time: 0.008        +\n     Actual Rows: 0                  +\n     Actual Loops: 1                 +\n     Index Cond: &quot;(id = 1)&quot;          +\n     Rows Removed by Index Recheck: 0+\n   Triggers:                         +\n   Total Runtime: 0.036\n(1 row)\n</code></pre>\n\n<p>现在我们只需要关注 &quot;Plan Rows&quot; 和 &quot;Actual Rows&quot;\n  - Plan Rows 在最坏的情况下，数据库需要循环多少行来响应你的查询\n  - Actual Rows 当它执行这次查询时，数据库实际循环了多少行？</p>\n\n<p>如果&quot;Plan Rows&quot; 是1，就像上边这样，那么这次查询可能是高效的。如果&quot;Plan Rows&quot; 等于这个数据库的行数，那么意味着这次查询将会做一个“全表扫描”，并不够好。</p>\n\n<p>既然你知道了怎样来测量查询的效率，那我们来看一些常规的rails语句，看它们是怎么运行的。</p>\n\n<h5>　　</h5>\n\n<h2>计数(Counting)</h2>\n\n<p>在Rails views中经常看到这样的代码：\n<code>\nTotal Faults &lt;%= Fault.count %&gt;\n</code>\n对应的SQL为：\n<code>\nselect count(*) from faults;\n</code>\n让我们把它放到<code>explain</code>里看看会发生什么。</p>\n\n<pre><code># explain (analyze, format yaml) select count(*) from faults;\n              QUERY PLAN\n--------------------------------------\n - Plan:                             +\n     Node Type: &quot;Aggregate&quot;          +\n     Strategy: &quot;Plain&quot;               +\n     Startup Cost: 1840.31           +\n     Total Cost: 1840.32             +\n     Plan Rows: 1                    +\n     Plan Width: 0                   +\n     Actual Startup Time: 24.477     +\n     Actual Total Time: 24.477       +\n     Actual Rows: 1                  +\n     Actual Loops: 1                 +\n     Plans:                          +\n       - Node Type: &quot;Seq Scan&quot;       +\n         Parent Relationship: &quot;Outer&quot;+\n         Relation Name: &quot;faults&quot;     +\n         Alias: &quot;faults&quot;             +\n         Startup Cost: 0.00          +\n         Total Cost: 1784.65         +\n         Plan Rows: 22265            +\n         Plan Width: 0               +\n         Actual Startup Time: 0.311  +\n         Actual Total Time: 22.839   +\n         Actual Rows: 22265          +\n         Actual Loops: 1             +\n   Triggers:                         +\n   Total Runtime: 24.555\n(1 row)\n</code></pre>\n\n<p>哇，我们的示例count查询循环了22265行 — 整个表！在postgres中，counts总是循环整个数据集。\n你可以通过加上<code>where</code>条件来减少数据集的大小。取决于你的要求，你可以减到足够小直到效率可以接受。</p>\n\n<p>另外一个解决此问题的方法是把你的count值缓存起来。<a href=\"https://ruby-china.org/topics/32073\">你可以这样来做：</a>\n<code>\nbelongs_to :project, :counter_cache =&gt; true\n</code>\n另外，当去检查这次查询是否返回任何数据时，用<code>Users.exists?</code>而不是<code>Users.count&gt;0</code>。这样查询的结果更加高效。</p>\n\n<h5>　　</h5>\n\n<h2>排序(Sorting)</h2>\n\n<p>几乎每个程序都至少有一个index页面，你从数据库里面读取了最新的20条记录然后展示出来。怎样做更简单？</p>\n\n<p>读数据的代码大概像这样：\n<code>\n@faults = Fault.order(created_at: :desc)\n</code>\n对应的sql为：\n<code>\nselect * from faults order by created_at desc;\n</code>\n那么我们来分析一下：</p>\n\n<pre><code># explain (analyze, format yaml) select * from faults order by created_at desc;\n              QUERY PLAN\n--------------------------------------\n - Plan:                             +\n     Node Type: &quot;Sort&quot;               +\n     Startup Cost: 39162.46          +\n     Total Cost: 39218.12            +\n     Plan Rows: 22265                +\n     Plan Width: 1855                +\n     Actual Startup Time: 75.928     +\n     Actual Total Time: 86.460       +\n     Actual Rows: 22265              +\n     Actual Loops: 1                 +\n     Sort Key:                       +\n       - &quot;created_at&quot;                +\n     Sort Method: &quot;external merge&quot;   +\n     Sort Space Used: 10752          +\n     Sort Space Type: &quot;Disk&quot;         +\n     Plans:                          +\n       - Node Type: &quot;Seq Scan&quot;       +\n         Parent Relationship: &quot;Outer&quot;+\n         Relation Name: &quot;faults&quot;     +\n         Alias: &quot;faults&quot;             +\n         Startup Cost: 0.00          +\n         Total Cost: 1784.65         +\n         Plan Rows: 22265            +\n         Plan Width: 1855            +\n         Actual Startup Time: 0.004  +\n         Actual Total Time: 4.653    +\n         Actual Rows: 22265          +\n         Actual Loops: 1             +\n   Triggers:                         +\n   Total Runtime: 102.288\n(1 row)\n</code></pre>\n\n<p>这里我们可以看到，每次你做这个查询时数据库会对所有的22265行进行排序。这样可不好。</p>\n\n<p>默认情况下，SQL中的每个<code>order_by</code>语句都会实时地对数据集排序，没有缓存。</p>\n\n<p>解决方法是使用index。像这种简单的情况，加一个sorted index到created_at column中将会大大提高查询速度。</p>\n\n<p>在你的Rails migration中你可以：</p>\n\n<pre><code>class AddIndexToFaultCreatedAt &lt; ActiveRecord::Migration\n  def change\n    add_index(:faults, :created_at)\n  end\nend\n</code></pre>\n\n<p>这会运行以下的SQL:\n<code>\nCREATE INDEX index_faults_on_created_at ON faults USING btree (created_at);\n</code>\n这里最后的<code>created_at</code>指的是排列顺序，默认是升序。</p>\n\n<p>现在我们再运行一下排序的查询，我们可以看到不再包含一个排序的步骤了，只是简单地从index里读取已经排序好的数据。</p>\n\n<pre><code># explain (analyze, format yaml) select * from faults order by created_at desc;\n                  QUERY PLAN\n----------------------------------------------\n - Plan:                                     +\n     Node Type: &quot;Index Scan&quot;                 +\n     Scan Direction: &quot;Backward&quot;              +\n     Index Name: &quot;index_faults_on_created_at&quot;+\n     Relation Name: &quot;faults&quot;                 +\n     Alias: &quot;faults&quot;                         +\n     Startup Cost: 0.29                      +\n     Total Cost: 5288.04                     +\n     Plan Rows: 22265                        +\n     Plan Width: 1855                        +\n     Actual Startup Time: 0.023              +\n     Actual Total Time: 8.778                +\n     Actual Rows: 22265                      +\n     Actual Loops: 1                         +\n   Triggers:                                 +\n   Total Runtime: 10.080\n(1 row)\n</code></pre>\n\n<p>如果你要依据多个columns排序，你需要创建一个由多个columns排序的index。在Rails migration中：\n<code>\nadd_index(:faults, [:priority, :created_at], order: {priority: :asc, created_at: :desc)\n</code>\n当你开始做更复杂的查询时，通过explain来执行它们是一个好办法，要趁早并且经常这样。</p>\n\n<h5>　　</h5>\n\n<h2>Limits and Offsets</h2>\n\n<p>我们多半不会把数据库中的所有数据都放到一个index页面里展示。我们用的是paginate，一次只显示10, 30或者50条。实现这个的最常规的方法是用limit和offset：\n<code>\nFault.limit(10).offset(100)\n</code>\n对应的SQL为：\n<code>\nselect * from faults limit 10 offset 100;\n</code>\n现在如果我们运行explain，可以看到一些奇怪的东西。扫描的行数是110，等于limit加上offset。</p>\n\n<pre><code># explain (analyze, format yaml) select * from faults limit 10 offset 100;\n              QUERY PLAN\n--------------------------------------\n - Plan:                             +\n     Node Type: &quot;Limit&quot;              +\n     ...\n     Plans:                          +\n       - Node Type: &quot;Seq Scan&quot;       +\n         Actual Rows: 110            +\n         ...\n</code></pre>\n\n<p>如果你把offset改成10000你会看到扫描的行数跳到了10010，这个查询会变慢64倍。</p>\n\n<pre><code># explain (analyze, format yaml) select * from faults limit 10 offset 10000;\n              QUERY PLAN\n--------------------------------------\n - Plan:                             +\n     Node Type: &quot;Limit&quot;              +\n     ...\n     Plans:                          +\n       - Node Type: &quot;Seq Scan&quot;       +\n         Actual Rows: 10010          +\n         ...\n</code></pre>\n\n<p>这就可以得出一个不好的结论：当分页的时候，后面的页面要比靠前的页面加载得慢。假设一个页面有100条记录(像上面这个示例一样)，那么第100页将比第一页慢13倍。</p>\n\n<p>那我们该怎么办？</p>\n\n<p>老实说，我还没有找到一个完美的解决方案。首先我想的是减小数据量，我就不用开始时分100页或者1000页了。</p>\n\n<p>如果你不能减少数据集，最好的方法可能是用<code>where</code>语句替换掉<code>offset/limit</code>。</p>\n\n<pre><code># You could use a date range\nFault.where(&quot;created_at &gt; ? and created_at &lt; ?&quot;, 100.days.ago, 101.days.ago)\n\n# ...or even an id range\nFault.where(&quot;id &gt; ? and id &lt; ?&quot;, 100, 200)\n</code></pre>\n\n<h5>　　</h5>\n\n<h2>结论</h2>\n\n<p>我希望这篇文章能够说服你，真的应该利用好postgres的explain这个功能来查找你数据库查询中潜在的性能问题。即使是最简单的查询也会导致重大的性能问题，所以这值得去检查。:)</p>\n\n<p><a href=\"http://blog.honeybadger.io/common-rails-idioms-that-kill-database-performance/\">原文链接</a></p>\n','# 前言\r\n关于数据库查询，让我们来看一看那些让你的程序停滞不前的罪魁祸首。\r\n\r\n我还记得我第一次看到rails的ActiveRecord，那是一次启发。那是2005年的时候，当时我在给一个PHP程序写SQL语句。突然间，写数据库从单调繁杂的零星工作变得简单且有趣了。\r\n\r\n...然后我就开始关注到性能(performance)的问题。\r\n\r\nActiveRecord它本身并不慢。我停止把注意力花在那些实际正在运行的查询上。结果是，当数据量变得庞大后，在rails的增删查改操作中一些最符合语言习惯的数据库查询就十分低效。\r\n\r\n这篇文章我们将讨论这其中的三个罪魁祸首。但首先，让我们先聊聊怎么知道你的数据库查询是否高效。\r\n##### 　　\r\n\r\n## 测量性能\r\n\r\n如果你数据量足够小的话每个数据库查询都是高效的。所以为了真正地感知效率，我们需要以一个生产级别的数据库为基准。在我们的示例中，我们将使用一个有大约22000条记录的叫做faults的表。\r\n\r\n我们会用到postgres。在postgres中，衡量性能的方法是使用explain。比如：\r\n\r\n    # explain (analyze) select * from faults where id = 1;\r\n                                         QUERY PLAN\r\n    ----------------------------------------------------------------------------------------\r\n     Index Scan using faults_pkey on faults  (cost=0.29..8.30 rows=1 width=1855) (actual \r\n    time=0.556..0.556 rows=0 loops=1)\r\n       Index Cond: (id = 1)\r\n     Total runtime: 0.626 ms\r\n\r\n这显示出了执行这次查询的预计花费 (cost=0.29..8.30 rows=1 width=1855) 和执行的实际时间(actual time=0.556..0.556 rows=0 loops=1)。\r\n\r\n如果你想要一个更易读的格式，你可以让postgres以YAML文件打印出来。\r\n\r\n    # explain (analyze, format yaml) select * from faults where id = 1;\r\n                  QUERY PLAN\r\n    --------------------------------------\r\n     - Plan:                             +\r\n         Node Type: \"Index Scan\"         +\r\n         Scan Direction: \"Forward\"       +\r\n         Index Name: \"faults_pkey\"       +\r\n         Relation Name: \"faults\"         +\r\n         Alias: \"faults\"                 +\r\n         Startup Cost: 0.29              +\r\n         Total Cost: 8.30                +\r\n         Plan Rows: 1                    +\r\n         Plan Width: 1855                +\r\n         Actual Startup Time: 0.008      +\r\n         Actual Total Time: 0.008        +\r\n         Actual Rows: 0                  +\r\n         Actual Loops: 1                 +\r\n         Index Cond: \"(id = 1)\"          +\r\n         Rows Removed by Index Recheck: 0+\r\n       Triggers:                         +\r\n       Total Runtime: 0.036\r\n    (1 row)\r\n\r\n现在我们只需要关注 \"Plan Rows\" 和 \"Actual Rows\"\r\n  - Plan Rows 在最坏的情况下，数据库需要循环多少行来响应你的查询\r\n  - Actual Rows 当它执行这次查询时，数据库实际循环了多少行？\r\n\r\n如果\"Plan Rows\" 是1，就像上边这样，那么这次查询可能是高效的。如果\"Plan Rows\" 等于这个数据库的行数，那么意味着这次查询将会做一个“全表扫描”，并不够好。\r\n\r\n既然你知道了怎样来测量查询的效率，那我们来看一些常规的rails语句，看它们是怎么运行的。\r\n##### 　　\r\n## 计数(Counting)\r\n在Rails views中经常看到这样的代码：\r\n```\r\nTotal Faults <%= Fault.count %>\r\n```\r\n对应的SQL为：\r\n```\r\nselect count(*) from faults;\r\n```\r\n让我们把它放到`explain`里看看会发生什么。\r\n\r\n    # explain (analyze, format yaml) select count(*) from faults;\r\n                  QUERY PLAN\r\n    --------------------------------------\r\n     - Plan:                             +\r\n         Node Type: \"Aggregate\"          +\r\n         Strategy: \"Plain\"               +\r\n         Startup Cost: 1840.31           +\r\n         Total Cost: 1840.32             +\r\n         Plan Rows: 1                    +\r\n         Plan Width: 0                   +\r\n         Actual Startup Time: 24.477     +\r\n         Actual Total Time: 24.477       +\r\n         Actual Rows: 1                  +\r\n         Actual Loops: 1                 +\r\n         Plans:                          +\r\n           - Node Type: \"Seq Scan\"       +\r\n             Parent Relationship: \"Outer\"+\r\n             Relation Name: \"faults\"     +\r\n             Alias: \"faults\"             +\r\n             Startup Cost: 0.00          +\r\n             Total Cost: 1784.65         +\r\n             Plan Rows: 22265            +\r\n             Plan Width: 0               +\r\n             Actual Startup Time: 0.311  +\r\n             Actual Total Time: 22.839   +\r\n             Actual Rows: 22265          +\r\n             Actual Loops: 1             +\r\n       Triggers:                         +\r\n       Total Runtime: 24.555\r\n    (1 row)\r\n\r\n\r\n哇，我们的示例count查询循环了22265行 — 整个表！在postgres中，counts总是循环整个数据集。\r\n你可以通过加上`where`条件来减少数据集的大小。取决于你的要求，你可以减到足够小直到效率可以接受。\r\n\r\n另外一个解决此问题的方法是把你的count值缓存起来。[你可以这样来做：](https://ruby-china.org/topics/32073)\r\n`\r\nbelongs_to :project, :counter_cache => true\r\n`\r\n另外，当去检查这次查询是否返回任何数据时，用`Users.exists?`而不是`Users.count>0`。这样查询的结果更加高效。\r\n##### 　　\r\n## 排序(Sorting)\r\n\r\n几乎每个程序都至少有一个index页面，你从数据库里面读取了最新的20条记录然后展示出来。怎样做更简单？\r\n\r\n读数据的代码大概像这样：\r\n`\r\n@faults = Fault.order(created_at: :desc)\r\n`\r\n对应的sql为：\r\n`\r\nselect * from faults order by created_at desc;\r\n`\r\n那么我们来分析一下：\r\n\r\n    # explain (analyze, format yaml) select * from faults order by created_at desc;\r\n                  QUERY PLAN\r\n    --------------------------------------\r\n     - Plan:                             +\r\n         Node Type: \"Sort\"               +\r\n         Startup Cost: 39162.46          +\r\n         Total Cost: 39218.12            +\r\n         Plan Rows: 22265                +\r\n         Plan Width: 1855                +\r\n         Actual Startup Time: 75.928     +\r\n         Actual Total Time: 86.460       +\r\n         Actual Rows: 22265              +\r\n         Actual Loops: 1                 +\r\n         Sort Key:                       +\r\n           - \"created_at\"                +\r\n         Sort Method: \"external merge\"   +\r\n         Sort Space Used: 10752          +\r\n         Sort Space Type: \"Disk\"         +\r\n         Plans:                          +\r\n           - Node Type: \"Seq Scan\"       +\r\n             Parent Relationship: \"Outer\"+\r\n             Relation Name: \"faults\"     +\r\n             Alias: \"faults\"             +\r\n             Startup Cost: 0.00          +\r\n             Total Cost: 1784.65         +\r\n             Plan Rows: 22265            +\r\n             Plan Width: 1855            +\r\n             Actual Startup Time: 0.004  +\r\n             Actual Total Time: 4.653    +\r\n             Actual Rows: 22265          +\r\n             Actual Loops: 1             +\r\n       Triggers:                         +\r\n       Total Runtime: 102.288\r\n    (1 row)\r\n\r\n这里我们可以看到，每次你做这个查询时数据库会对所有的22265行进行排序。这样可不好。\r\n\r\n默认情况下，SQL中的每个`order_by`语句都会实时地对数据集排序，没有缓存。\r\n\r\n解决方法是使用index。像这种简单的情况，加一个sorted index到created_at column中将会大大提高查询速度。\r\n\r\n在你的Rails migration中你可以：\r\n\r\n    class AddIndexToFaultCreatedAt < ActiveRecord::Migration\r\n      def change\r\n        add_index(:faults, :created_at)\r\n      end\r\n    end\r\n\r\n这会运行以下的SQL:\r\n`\r\nCREATE INDEX index_faults_on_created_at ON faults USING btree (created_at);\r\n`\r\n这里最后的`created_at`指的是排列顺序，默认是升序。\r\n\r\n现在我们再运行一下排序的查询，我们可以看到不再包含一个排序的步骤了，只是简单地从index里读取已经排序好的数据。\r\n\r\n    # explain (analyze, format yaml) select * from faults order by created_at desc;\r\n                      QUERY PLAN\r\n    ----------------------------------------------\r\n     - Plan:                                     +\r\n         Node Type: \"Index Scan\"                 +\r\n         Scan Direction: \"Backward\"              +\r\n         Index Name: \"index_faults_on_created_at\"+\r\n         Relation Name: \"faults\"                 +\r\n         Alias: \"faults\"                         +\r\n         Startup Cost: 0.29                      +\r\n         Total Cost: 5288.04                     +\r\n         Plan Rows: 22265                        +\r\n         Plan Width: 1855                        +\r\n         Actual Startup Time: 0.023              +\r\n         Actual Total Time: 8.778                +\r\n         Actual Rows: 22265                      +\r\n         Actual Loops: 1                         +\r\n       Triggers:                                 +\r\n       Total Runtime: 10.080\r\n    (1 row)\r\n\r\n如果你要依据多个columns排序，你需要创建一个由多个columns排序的index。在Rails migration中：\r\n`\r\nadd_index(:faults, [:priority, :created_at], order: {priority: :asc, created_at: :desc)\r\n`\r\n当你开始做更复杂的查询时，通过explain来执行它们是一个好办法，要趁早并且经常这样。\r\n##### 　　\r\n## Limits and Offsets\r\n我们多半不会把数据库中的所有数据都放到一个index页面里展示。我们用的是paginate，一次只显示10, 30或者50条。实现这个的最常规的方法是用limit和offset：\r\n`\r\nFault.limit(10).offset(100)\r\n`\r\n对应的SQL为：\r\n`\r\nselect * from faults limit 10 offset 100;\r\n`\r\n现在如果我们运行explain，可以看到一些奇怪的东西。扫描的行数是110，等于limit加上offset。\r\n\r\n    # explain (analyze, format yaml) select * from faults limit 10 offset 100;\r\n                  QUERY PLAN\r\n    --------------------------------------\r\n     - Plan:                             +\r\n         Node Type: \"Limit\"              +\r\n         ...\r\n         Plans:                          +\r\n           - Node Type: \"Seq Scan\"       +\r\n             Actual Rows: 110            +\r\n             ...\r\n\r\n如果你把offset改成10000你会看到扫描的行数跳到了10010，这个查询会变慢64倍。\r\n\r\n    # explain (analyze, format yaml) select * from faults limit 10 offset 10000;\r\n                  QUERY PLAN\r\n    --------------------------------------\r\n     - Plan:                             +\r\n         Node Type: \"Limit\"              +\r\n         ...\r\n         Plans:                          +\r\n           - Node Type: \"Seq Scan\"       +\r\n             Actual Rows: 10010          +\r\n             ...\r\n\r\n这就可以得出一个不好的结论：当分页的时候，后面的页面要比靠前的页面加载得慢。假设一个页面有100条记录(像上面这个示例一样)，那么第100页将比第一页慢13倍。\r\n\r\n那我们该怎么办？\r\n\r\n老实说，我还没有找到一个完美的解决方案。首先我想的是减小数据量，我就不用开始时分100页或者1000页了。\r\n\r\n如果你不能减少数据集，最好的方法可能是用`where`语句替换掉`offset/limit`。\r\n\r\n    # You could use a date range\r\n    Fault.where(\"created_at > ? and created_at < ?\", 100.days.ago, 101.days.ago)\r\n\r\n    # ...or even an id range\r\n    Fault.where(\"id > ? and id < ?\", 100, 200)\r\n\r\n##### 　　\r\n## 结论\r\n我希望这篇文章能够说服你，真的应该利用好postgres的explain这个功能来查找你数据库查询中潜在的性能问题。即使是最简单的查询也会导致重大的性能问题，所以这值得去检查。:)\r\n\r\n[原文链接](http://blog.honeybadger.io/common-rails-idioms-that-kill-database-performance/)','2017-01','^^翻译^^数据库','2017-01-09 00:00:00','2017-01-09 00:00:00'),(7,'JS 简单实现弹出层效果','<h3>起源</h3>\n\n<p>今天在添加微信联系方式的时候有了这个需求：需要点击按钮后弹出一个显示图片的对话框。</p>\n\n<p>很简单的一个功能，我一开始想的是直接用<code>alert()</code>来弹出对话框然后显示图片，然后发现似乎这样并不能插入图片。\n而且为了实现更酷炫的效果，最后我采用了以下方法:</p>\n\n<h3>思路</h3>\n\n<p>1.在页面中央直接摆放好图片，初始状态设为不显示；</p>\n\n<p>2.放置一个覆盖整个页面的div，堆叠到图片下层，用于实现背景效果，初始状态也是不显示；</p>\n\n<p>3.按钮的onclick事件来触发openWindow()，控制1、2的显示；</p>\n\n<p>4.点击背景div触发closewindow事件，将显示状态还原。</p>\n\n<h3>页面代码</h3>\n\n<pre><code>&lt;img src=&quot;/wechat.png&quot; alt=&quot;点击弹出二维码&quot; onclick=&quot;openWindow()&quot; /&gt;  # 这个当按钮\n\n&lt;div id=&quot;black_overlay&quot; onclick=&quot;closeWindow()&quot;&gt;&lt;/div&gt;  # 这是遮罩层背景\n\n&lt;%= image_tag &#39;wechat_add.png&#39;, id: &quot;wechat&quot; %&gt;  # 这是要弹出显示的图片\n</code></pre>\n\n<h3>JS</h3>\n\n<pre><code>function openWindow(){\n  document.getElementById(&#39;wechat&#39;).style.display = &#39;block&#39;;\n  document.getElementById(&#39;black_overlay&#39;).style.display=&#39;block&#39;;\n}\n\nfunction closeWindow(){\n  document.getElementById(&#39;wechat&#39;).style.display = &#39;none&#39;;\n  document.getElementById(&#39;black_overlay&#39;).style.display=&#39;none&#39;;\n}\n</code></pre>\n\n<h3>CSS</h3>\n\n<pre><code> #wechat{\n   height: 400px;\n   width: 450px;\n   display: none;\n   position: abosluted;\n   top: 20%;\n   left: 35%;\n   z-index: 1002;\n }\n\n #black_overlay{\n   display: none;\n   position: absoluted;\n   background-color: black;\n   z-index: 1001;\n   left: 0%;\n   top: 0%;\n   width: 100%;\n   height: 100%;\n   opacity: 0.8;\n   -moz-opacity: 0.8;\n   filter: alpha(opacity=80); \n }\n</code></pre>\n\n<h3>效果</h3>\n\n<p>最后实现的效果如下：</p>\n\n<p><img src=\"/wechat_qr.png\" alt=\"pic\" height=\"350px\" width=\"510px\" /></p>\n','\r\n### 起源\r\n\r\n今天在添加微信联系方式的时候有了这个需求：需要点击按钮后弹出一个显示图片的对话框。\r\n\r\n很简单的一个功能，我一开始想的是直接用`alert()`来弹出对话框然后显示图片，然后发现似乎这样并不能插入图片。\r\n而且为了实现更酷炫的效果，最后我采用了以下方法:\r\n\r\n### 思路\r\n\r\n1.在页面中央直接摆放好图片，初始状态设为不显示；\r\n\r\n2.放置一个覆盖整个页面的div，堆叠到图片下层，用于实现背景效果，初始状态也是不显示；\r\n\r\n3.按钮的onclick事件来触发openWindow()，控制1、2的显示；\r\n\r\n4.点击背景div触发closewindow事件，将显示状态还原。\r\n\r\n### 页面代码\r\n\r\n    <img src=\"/wechat.png\" alt=\"点击弹出二维码\" onclick=\"openWindow()\" />  # 这个当按钮\r\n\r\n    <div id=\"black_overlay\" onclick=\"closeWindow()\"></div>  # 这是遮罩层背景\r\n\r\n    <%= image_tag \'wechat_add.png\', id: \"wechat\" %>  # 这是要弹出显示的图片\r\n\r\n### JS\r\n\r\n    function openWindow(){\r\n      document.getElementById(\'wechat\').style.display = \'block\';\r\n      document.getElementById(\'black_overlay\').style.display=\'block\';\r\n    }\r\n\r\n    function closeWindow(){\r\n      document.getElementById(\'wechat\').style.display = \'none\';\r\n      document.getElementById(\'black_overlay\').style.display=\'none\';\r\n    }\r\n\r\n### CSS\r\n\r\n     #wechat{\r\n       height: 400px;\r\n       width: 450px;\r\n       display: none;\r\n       position: abosluted;\r\n       top: 20%;\r\n       left: 35%;\r\n       z-index: 1002;\r\n     }\r\n\r\n     #black_overlay{\r\n       display: none;\r\n       position: absoluted;\r\n       background-color: black;\r\n       z-index: 1001;\r\n       left: 0%;\r\n       top: 0%;\r\n       width: 100%;\r\n       height: 100%;\r\n       opacity: 0.8;\r\n       -moz-opacity: 0.8;\r\n       filter: alpha(opacity=80); \r\n     }\r\n\r\n### 效果\r\n\r\n最后实现的效果如下：\r\n\r\n<img src=\"/wechat_qr.png\" alt=\"pic\" height=\"350px\" width=\"510px\" />\r\n\r\n','2017-03','^^JS^^CSS','2017-03-16 12:19:23','2017-03-18 10:17:49'),(8,'写在“毕业”之际','<p>　　上周回学校审了毕业论文初稿。毕业论文！是啊，这预示着我即将大学毕业了！</p>\n\n<p>　　毕业聚餐早已过去，上一次在学校上课已不记得是哪天了，虽然心里感觉自己早已是毕业状态，但一些标志性的日子终将要到来。审论文、清学分、拿证，大学三年即将结束，又一次要各奔东西了。标题之所以打个引号，是因为对于我来说可能大学还有两年的延长期:(</p>\n\n<div style=\"text-align:center;\"><img src=\"/qc.png\" alt=\"qc\" /></div>\n\n<p>　　不论如何，这【极其短暂】的三年快走完了，回顾这大学三年，真的感觉过得飞快，如果和高中的三年比起来，这就像是一年，甚至还不到。回想高中的日子，每天起早贪黑的学习生活，为了一个单纯的目标不断奋斗的日子，那种感受，那种状态，这辈子可能再也回不去了（我也不想再回去，因为实在太苦逼太黑暗）。</p>\n\n<p>　　我曾经计划每学期写一次总结，但好像除了大一后来都没写过，现在快要结束了，还是简单总结一下吧。</p>\n\n<h3>大一（部分摘自以前的日志）</h3>\n\n<p>　　大一一晃就结束了，感觉过得非常之快。</p>\n\n<p>　　初进大学，第一天是相当激动而失落的，激动是因为新的环境、新的生活，失落也是因为陌生的环境、没有一个认识的人，我记得我第一天晚上去操场独自散步后甚至忘了怎么走回寝室（本来我就是彻底路痴）。好在开学之前我就从群里认识了不少素未谋面的同学，我们聚在一起玩牌、玩游戏，虽然大家都不认识。</p>\n\n<p>　　生活似乎是从严苛的军训开始的，这让我感觉还处在高中状态，每天很累，但晚上回寝室也很安静，没人玩游戏，没有人说很多话，大家都早点洗洗睡，感觉还是有几分拘束的。那是还在想晚上电脑拿出来会不会被没收，平时能不能出校门之类的问题，现在看来真是把自己当高中生啊！</p>\n\n<p><img src=\"/jx.jpg\" alt=\"jx\" height=300px width=200px /></p>\n\n<p>　　总的来说，大学刚开始一段时间大家都还是那种学生状态的，该集合的集合，该上课的上课，该做什么做什么，不敢丝毫懈怠。不过过了那段时间，越到后来，大家就越松懈了，集合点名基本不能到齐了，逃课的比教室里的还多了，你起床发现那哥们开始关电脑睡觉了，你去应聘发现你同学在招聘人了……其实大学就是这样，是一个相对自由的时期，不是每天被迫学习，也不是放开了耍。每个人对待大学都有自己的态度，每个人在大学都有自己的生活方式，走着不同的属于自己的路。引用一段话，我认为写得相当好：</p>\n\n<pre><code>有人大清早就去了自习室，直到熄灯才回来；有人整天宅在宿舍里玩游戏，熬到半夜中午才起；\n\n有人在学生会社团工作很出色，为人行事各种通达；有人收获了爱情，每天从早到晚眼里只有一个人；\n\n有人热爱运动，运动场上永远少不了他的身影；有人找兼职赚钱，为此受了不少磨练；\n\n有人喜欢旅行，翘课，哪怕没钱，也风雨无阻；有人做科研项目，白天黑夜，完全忘我；\n\n有人随波逐流，永远跟着大军，上课下课吃饭睡觉周末休息再上课；\n\n有人追求着错误的东西义无反顾，但却觉得人的一生应该追求一次自己想要的东西，哪怕是错的。\n\n有人笑，有人哭，有人沉默，有人兴奋，有人幸福。\n\n这 就是大学，每个人做着自己做的事情，没有对与错。\n\n谁都没有真正意义上是非曲直的标尺，谁都有为自己伸张正义的自由和理由，谁都有自己的人生准则和方向。\n\n谁都可以随时堕落和振作。\n\n多年以后，这各式各样的人中不见得谁混的一定比谁差。\n\n整天泡自习室的人也许成了教授，翘课做兼职的人也许成了公司老总，宅在宿舍玩游戏的人也许进了知名游戏公司\n\n做高级工程师，出去旅行的人也许单反玩的很溜成了摄影家，收获爱情的人也许此生和爱的人过着平淡的生活\n\n但只要这是他们定义的幸福，他们就是幸福的。\n\n生活没有三六九等，只要你做的是你的梦想中要做的事，你就是站在属于你自己的巅峰上，这也就够了\n</code></pre>\n\n<h3> </h3>\n\n<p>　　说实话，大一从学习上来说，除了微积分的一点知识外，其他的基本没有学习什么东西（微积分现在也忘完了）。图书馆一学期下来总共只去过两次，晨跑也只有5次，大多数时候没课还是不会提前起床。</p>\n\n<p>　　生活上来说，刚开学的军训真是很累，之后慢慢就适应了大学生活。</p>\n\n<p>　　刚行课时和期末的时候都是比较轻松的，我没有为期末考试不挂科花太多时间，因为毕竟平时还是多少在学的（虽然学的东西没什么用）。只有中间那段时间比较忙，工作上任务多，学习上课也比较多。我记得最忙的那几天真是东奔西走，开会策划等等，一个任务还没完下一个任务又来了。过了那段时间还真是比较闲了，到最后每周只有几节课了，都是非常自由的。我想大学时光可能是我一生中最美好的时光了。高中学习压力很大，到了大学学习压力是小很多了，但大学就像一个社会，要处理各方面的事务，不仅仅是学习，还有班级事务，社团工作，生活琐事等等。（现在回想起来，有些社团是扯淡的，当初我交了90元的会费然后，就没有然后了...）</p>\n\n<p>　　学校开的课真没什么意思，因为我觉得听了也根本没有意义，那些时间还不如自己去图书馆自习。（我想说一句不该说的话：什么锦城课堂大于天，我觉得就是浪费时间。不是说学校不好，但真的..唉，这个问题就扯远了）</p>\n\n<p>　　在大学每个人都是扮演着多个角色。大一我担任了班长、计算机科代表、英语组长、外事英语协会成员、钢琴协会成员，此外还参加了系篮球队、外语社和心理协会。</p>\n\n<p>　　其实作为英语组长，英语作业我真是一次都没做过，老实说我根本不知道有些啥作业。外协和我想象中还是有些不一样，刚开始面试的时候还是比较紧张，后来还是通过了。开始还是比较积极的，帮部长做事、交流会上台发言。后来感觉我们学习部基本没什么任务了，就是早上去管晨读，不过感觉也只是去打酱油而已。协会聚餐和活动部有几次活动我也没去参加，不知道搞得怎么样。</p>\n\n<p>　　阴差阳错兼任了学习委员和班长，班级大小事务都由我负责，这让我学会了担当。感觉我为班级还是做了很多事的，从设计班徽、每周组织课外活动，到写策划、开会、组织答辩、发通知、发礼物等等，通过这些多多少少都锻炼了我自己。</p>\n\n<p>　　在大一，班级事务确实占用了我一部分时间。很多人都在寻找大学的社团、班级事务与学习之间的平衡。我还记得当初我想当学习委员的初衷就是想更多的是搞学习方面的事，但后来我发现并不是这样的，什么学习委员劳动委员娱乐委员其实都一样。那段时间我经常在思考，花的这些时间，到底有没有价值。我认为班干部应该是不求回报的，为班级作出贡献是职责所当，但得到的报酬是一些宝贵的经验、经历，可以锻炼自己，学会与人交流沟通，与同学协商合作，学会怎样去完成一次策划，怎样组织大家参加一次集体活动，认识更多的人和事，慢慢建立起一个交际网。这些都是宝贵的财富，虽然有时确实比较累，但我想还是多多少少会有收获的吧。</p>\n\n<h3>大二</h3>\n\n<p>　　转眼就到了大二，这一开学，我就开始为各种考试和比赛而准备。</p>\n\n<p>　　第一次NCRE二级C考试我由于准备不充分，考试时最后一个离开考场结果还是败下阵来，NECCS也是名落孙山，当时特别沮丧，所以我想这次我一定要一雪前耻。于是通过努力，第二次考二级C不到1小时我就交卷了，因为我知道No Problem! 这是小托马斯般的自信。</p>\n\n<p>　　接下来，热爱计算机的我当然不甘心止步二级，哪怕只是为了一个证书。于是我一次性报考了三级+四级，报的时候老师还说不要这样同时报，因为我们学校从来没有人同时通过三四级。我半信半疑的把三级报了就回寝室了，回去后越想越不对劲：凭什么不能同时报？以前没有人过，但凡事总有第一次啊，我会用成绩证明给你看的。于是第二天我哗哗地跑去把四级一起报了。接下来就是一段艰苦的学习时光，我可不想浪费180大洋的报名费，三月底要搞定三四级，另外参加的创业大赛要着手写策划书，四月初还报了全国征文比赛，四月中旬的第二次NECCS我希望能理想一点，同时我还在兼职做点小生意，开发了一个会员系统。</p>\n\n<p><img src=\"/sys.jpg\" alt=\"sys\" height=400px width=600px /></p>\n\n<p>　　天哪，我竟然给自己安排了那么多事。不得不说那段时间真是过得相当充实的，学校要求我们一学期在图书馆坐满900分钟还是多少分钟来着，就只是3月份我就在图书馆待了77个小时（日历上红色的就是时间），不算休息日，平均每天都要在图书馆自学3.5个小时，其实也就是除了上课吃饭睡觉都在图书馆，晚上下着大雨打着伞也要去，经常22点图书馆关门了才被迫走，真的是风雨兼程。</p>\n\n<p><img src=\"/rl.jpg\" alt=\"rl\" style=\"transform: rotate(90deg); height: 330px; width: 500px; margin: 70px;\" /></p>\n\n<p>　　其实我觉得我的学习效率真的不高，换做别人应该不需要这么多的时间准备考试的。不过总算功夫不负有心人，花了这么多时间，最终我成为了我们学校第一个高分同时通过计算机三四级的童鞋（后来我才知道计算机专业毕业即4级），拿到了获奖率0.5%的全国英语竞赛一等奖，同时兼职做某事营业额达到五六千（虽然最后利润几乎为0）。写这些不是说我多么厉害，只是我真的为自己努力后的成果感到高兴。或许我们有时真的应该问问自己：比你优秀的人都比你还努力，你凭什么不努力？如果问我大学做的最有意义的事情，我觉得可能就是这次了。</p>\n\n<p>　　正如马云说的：<strong>人必须要有自己坚信不疑的事情，如果你没有坚信不疑的东西，你不会走下去，尽管一开始你只是坚信了一点点，但是你越做越发现一切皆有可能，自己要相信自己，坚信自己在做什么。</strong></p>\n\n<p>　　当然，我一开始也不相信我会当5门课的科代表：</p>\n\n<p><img src=\"/kdb.jpg\" alt=\"sys\" height=440px width=300px /></p>\n\n<h3>大三</h3>\n\n<p>　　整个大三的主要时间都是实习，但为了能顺利适应工作，我并没有急着去找实习，因为我还是觉得自己学到的东西太少了。但是学校又在催实习，于是我在开学前提前了两周来学校。</p>\n\n<p>　　到了学校发现确实很早，店铺基本都没开门，食堂只有几个窗口，校园也很冷清。</p>\n\n<p>　　正是炎热的8月，到了寝室苦逼地发现电扇坏了！一个人在寝室，晚上蚊子很多，主要是太闷热了，根本睡不着！于是第二天五点半天还没亮我就起床了，我想去看看图书馆是否开门，结果还开得挺早的，一个人在图书馆特别特别安静！</p>\n\n<p><img src=\"/library.jpeg\" alt=\"sys\" height=370px width=530px /></p>\n\n<p>　　写着写着发现成流水账了，就先到这里吧。</p>\n\n<p>　　毕业之际，祝好！</p>\n','　　上周回学校审了毕业论文初稿。毕业论文！是啊，这预示着我即将大学毕业了！\r\n\r\n　　毕业聚餐早已过去，上一次在学校上课已不记得是哪天了，虽然心里感觉自己早已是毕业状态，但一些标志性的日子终将要到来。审论文、清学分、拿证，大学三年即将结束，又一次要各奔东西了。标题之所以打个引号，是因为对于我来说可能大学还有两年的延长期:(\r\n\r\n<div style=\"text-align:center;\"><img src=\"/qc.png\" alt=\"qc\" /></div>\r\n\r\n　　不论如何，这【极其短暂】的三年快走完了，回顾这大学三年，真的感觉过得飞快，如果和高中的三年比起来，这就像是一年，甚至还不到。回想高中的日子，每天起早贪黑的学习生活，为了一个单纯的目标不断奋斗的日子，那种感受，那种状态，这辈子可能再也回不去了（我也不想再回去，因为实在太苦逼太黑暗）。\r\n\r\n　　我曾经计划每学期写一次总结，但好像除了大一后来都没写过，现在快要结束了，还是简单总结一下吧。\r\n\r\n### 大一（部分摘自以前的日志）\r\n\r\n　　大一一晃就结束了，感觉过得非常之快。\r\n\r\n　　初进大学，第一天是相当激动而失落的，激动是因为新的环境、新的生活，失落也是因为陌生的环境、没有一个认识的人，我记得我第一天晚上去操场独自散步后甚至忘了怎么走回寝室（本来我就是彻底路痴）。好在开学之前我就从群里认识了不少素未谋面的同学，我们聚在一起玩牌、玩游戏，虽然大家都不认识。\r\n\r\n　　生活似乎是从严苛的军训开始的，这让我感觉还处在高中状态，每天很累，但晚上回寝室也很安静，没人玩游戏，没有人说很多话，大家都早点洗洗睡，感觉还是有几分拘束的。那是还在想晚上电脑拿出来会不会被没收，平时能不能出校门之类的问题，现在看来真是把自己当高中生啊！\r\n\r\n<img src=\"/jx.jpg\" alt=\"jx\" height=300px width=200px />\r\n\r\n\r\n　　总的来说，大学刚开始一段时间大家都还是那种学生状态的，该集合的集合，该上课的上课，该做什么做什么，不敢丝毫懈怠。不过过了那段时间，越到后来，大家就越松懈了，集合点名基本不能到齐了，逃课的比教室里的还多了，你起床发现那哥们开始关电脑睡觉了，你去应聘发现你同学在招聘人了……其实大学就是这样，是一个相对自由的时期，不是每天被迫学习，也不是放开了耍。每个人对待大学都有自己的态度，每个人在大学都有自己的生活方式，走着不同的属于自己的路。引用一段话，我认为写得相当好：\r\n\r\n    有人大清早就去了自习室，直到熄灯才回来；有人整天宅在宿舍里玩游戏，熬到半夜中午才起；\r\n\r\n    有人在学生会社团工作很出色，为人行事各种通达；有人收获了爱情，每天从早到晚眼里只有一个人；\r\n\r\n    有人热爱运动，运动场上永远少不了他的身影；有人找兼职赚钱，为此受了不少磨练；\r\n\r\n    有人喜欢旅行，翘课，哪怕没钱，也风雨无阻；有人做科研项目，白天黑夜，完全忘我；\r\n\r\n    有人随波逐流，永远跟着大军，上课下课吃饭睡觉周末休息再上课；\r\n\r\n    有人追求着错误的东西义无反顾，但却觉得人的一生应该追求一次自己想要的东西，哪怕是错的。\r\n\r\n    有人笑，有人哭，有人沉默，有人兴奋，有人幸福。\r\n\r\n    这 就是大学，每个人做着自己做的事情，没有对与错。\r\n\r\n    谁都没有真正意义上是非曲直的标尺，谁都有为自己伸张正义的自由和理由，谁都有自己的人生准则和方向。\r\n\r\n    谁都可以随时堕落和振作。\r\n\r\n    多年以后，这各式各样的人中不见得谁混的一定比谁差。\r\n\r\n    整天泡自习室的人也许成了教授，翘课做兼职的人也许成了公司老总，宅在宿舍玩游戏的人也许进了知名游戏公司\r\n\r\n    做高级工程师，出去旅行的人也许单反玩的很溜成了摄影家，收获爱情的人也许此生和爱的人过着平淡的生活\r\n\r\n    但只要这是他们定义的幸福，他们就是幸福的。\r\n\r\n    生活没有三六九等，只要你做的是你的梦想中要做的事，你就是站在属于你自己的巅峰上，这也就够了\r\n\r\n<h3> </h3>\r\n　　说实话，大一从学习上来说，除了微积分的一点知识外，其他的基本没有学习什么东西（微积分现在也忘完了）。图书馆一学期下来总共只去过两次，晨跑也只有5次，大多数时候没课还是不会提前起床。\r\n\r\n　　生活上来说，刚开学的军训真是很累，之后慢慢就适应了大学生活。\r\n \r\n　　刚行课时和期末的时候都是比较轻松的，我没有为期末考试不挂科花太多时间，因为毕竟平时还是多少在学的（虽然学的东西没什么用）。只有中间那段时间比较忙，工作上任务多，学习上课也比较多。我记得最忙的那几天真是东奔西走，开会策划等等，一个任务还没完下一个任务又来了。过了那段时间还真是比较闲了，到最后每周只有几节课了，都是非常自由的。我想大学时光可能是我一生中最美好的时光了。高中学习压力很大，到了大学学习压力是小很多了，但大学就像一个社会，要处理各方面的事务，不仅仅是学习，还有班级事务，社团工作，生活琐事等等。（现在回想起来，有些社团是扯淡的，当初我交了90元的会费然后，就没有然后了...）\r\n\r\n　　学校开的课真没什么意思，因为我觉得听了也根本没有意义，那些时间还不如自己去图书馆自习。（我想说一句不该说的话：什么锦城课堂大于天，我觉得就是浪费时间。不是说学校不好，但真的..唉，这个问题就扯远了）\r\n     \r\n　　在大学每个人都是扮演着多个角色。大一我担任了班长、计算机科代表、英语组长、外事英语协会成员、钢琴协会成员，此外还参加了系篮球队、外语社和心理协会。\r\n\r\n　　其实作为英语组长，英语作业我真是一次都没做过，老实说我根本不知道有些啥作业。外协和我想象中还是有些不一样，刚开始面试的时候还是比较紧张，后来还是通过了。开始还是比较积极的，帮部长做事、交流会上台发言。后来感觉我们学习部基本没什么任务了，就是早上去管晨读，不过感觉也只是去打酱油而已。协会聚餐和活动部有几次活动我也没去参加，不知道搞得怎么样。\r\n\r\n　　阴差阳错兼任了学习委员和班长，班级大小事务都由我负责，这让我学会了担当。感觉我为班级还是做了很多事的，从设计班徽、每周组织课外活动，到写策划、开会、组织答辩、发通知、发礼物等等，通过这些多多少少都锻炼了我自己。\r\n\r\n　　在大一，班级事务确实占用了我一部分时间。很多人都在寻找大学的社团、班级事务与学习之间的平衡。我还记得当初我想当学习委员的初衷就是想更多的是搞学习方面的事，但后来我发现并不是这样的，什么学习委员劳动委员娱乐委员其实都一样。那段时间我经常在思考，花的这些时间，到底有没有价值。我认为班干部应该是不求回报的，为班级作出贡献是职责所当，但得到的报酬是一些宝贵的经验、经历，可以锻炼自己，学会与人交流沟通，与同学协商合作，学会怎样去完成一次策划，怎样组织大家参加一次集体活动，认识更多的人和事，慢慢建立起一个交际网。这些都是宝贵的财富，虽然有时确实比较累，但我想还是多多少少会有收获的吧。\r\n\r\n### 大二\r\n\r\n　　转眼就到了大二，这一开学，我就开始为各种考试和比赛而准备。\r\n\r\n　　第一次NCRE二级C考试我由于准备不充分，考试时最后一个离开考场结果还是败下阵来，NECCS也是名落孙山，当时特别沮丧，所以我想这次我一定要一雪前耻。于是通过努力，第二次考二级C不到1小时我就交卷了，因为我知道No Problem! 这是小托马斯般的自信。\r\n\r\n　　接下来，热爱计算机的我当然不甘心止步二级，哪怕只是为了一个证书。于是我一次性报考了三级+四级，报的时候老师还说不要这样同时报，因为我们学校从来没有人同时通过三四级。我半信半疑的把三级报了就回寝室了，回去后越想越不对劲：凭什么不能同时报？以前没有人过，但凡事总有第一次啊，我会用成绩证明给你看的。于是第二天我哗哗地跑去把四级一起报了。接下来就是一段艰苦的学习时光，我可不想浪费180大洋的报名费，三月底要搞定三四级，另外参加的创业大赛要着手写策划书，四月初还报了全国征文比赛，四月中旬的第二次NECCS我希望能理想一点，同时我还在兼职做点小生意，开发了一个会员系统。\r\n\r\n<img src=\"/sys.jpg\" alt=\"sys\" height=400px width=600px />\r\n\r\n　　天哪，我竟然给自己安排了那么多事。不得不说那段时间真是过得相当充实的，学校要求我们一学期在图书馆坐满900分钟还是多少分钟来着，就只是3月份我就在图书馆待了77个小时（日历上红色的就是时间），不算休息日，平均每天都要在图书馆自学3.5个小时，其实也就是除了上课吃饭睡觉都在图书馆，晚上下着大雨打着伞也要去，经常22点图书馆关门了才被迫走，真的是风雨兼程。\r\n\r\n<img src=\"/rl.jpg\" alt=\"rl\" style=\"transform: rotate(90deg); height: 330px; width: 500px; margin: 70px;\" />\r\n\r\n　　其实我觉得我的学习效率真的不高，换做别人应该不需要这么多的时间准备考试的。不过总算功夫不负有心人，花了这么多时间，最终我成为了我们学校第一个高分同时通过计算机三四级的童鞋（后来我才知道计算机专业毕业即4级），拿到了获奖率0.5%的全国英语竞赛一等奖，同时兼职做某事营业额达到五六千（虽然最后利润几乎为0）。写这些不是说我多么厉害，只是我真的为自己努力后的成果感到高兴。或许我们有时真的应该问问自己：比你优秀的人都比你还努力，你凭什么不努力？如果问我大学做的最有意义的事情，我觉得可能就是这次了。\r\n\r\n　　正如马云说的：**人必须要有自己坚信不疑的事情，如果你没有坚信不疑的东西，你不会走下去，尽管一开始你只是坚信了一点点，但是你越做越发现一切皆有可能，自己要相信自己，坚信自己在做什么。**\r\n\r\n　　当然，我一开始也不相信我会当5门课的科代表：\r\n\r\n<img src=\"/kdb.jpg\" alt=\"sys\" height=440px width=300px />\r\n\r\n### 大三\r\n\r\n　　整个大三的主要时间都是实习，但为了能顺利适应工作，我并没有急着去找实习，因为我还是觉得自己学到的东西太少了。但是学校又在催实习，于是我在开学前提前了两周来学校。\r\n\r\n　　到了学校发现确实很早，店铺基本都没开门，食堂只有几个窗口，校园也很冷清。\r\n\r\n　　正是炎热的8月，到了寝室苦逼地发现电扇坏了！一个人在寝室，晚上蚊子很多，主要是太闷热了，根本睡不着！于是第二天五点半天还没亮我就起床了，我想去看看图书馆是否开门，结果还开得挺早的，一个人在图书馆特别特别安静！\r\n\r\n<img src=\"/library.jpeg\" alt=\"sys\" height=370px width=530px />\r\n\r\n　　写着写着发现成流水账了，就先到这里吧。\r\n\r\n　　毕业之际，祝好！','2017-03','^^长文^^感想','2017-03-16 13:27:41','2017-03-17 03:49:09'),(9,'在 Aliyun ECS 上用 Nginx + Passenger 部署 Rails 应用时安装 Passenger 的问题','<h3>问题</h3>\n\n<p>第一次部署Rails应用，参照<a href=\"https://github.com/ruby-china/homeland/wiki/Ubuntu-12.04-%E4%B8%8A%E4%BD%BF%E7%94%A8-Nginx-Passenger-%E9%83%A8%E7%BD%B2-Ruby-on-Rails\">资料1</a>  <a href=\"https://ruby-china.org/wiki/deploy-rails-on-ubuntu-server\">资料2</a>  <a href=\"https://github.com/huacnlee/init.d\">资料3</a>  <a href=\"https://github.com/ruby-china/homeland/wiki/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85-Rails-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83\">资料4</a>等资料在服务器上装好了ruby, rvm, 相关依赖等，但在安装passenger时，参照<a href=\"https://www.phusionpassenger.com/library/install/nginx/install/oss/xenial/\">此官方文档</a>，安装了秘钥和HTTP支持，也添加了APT源：\n<code>\nsudo sh -c &#39;echo deb https://oss-binaries.phusionpassenger.com/apt/passenger xenial main &gt; /etc/apt/sources.list.d/passenger.list&#39;\n</code></p>\n\n<p>但在执行 <code>sudo apt-get update</code>时遇到以下错误：</p>\n\n<pre><code>Hit:1 http://mirrors.cloud.aliyuncs.com/ubuntu xenial InRelease\nHit:2 http://mirrors.aliyun.com/ubuntu xenial InRelease\nGet:3 http://mirrors.cloud.aliyuncs.com/ubuntu xenial-security InRelease [102 kB]\nGet:4 http://mirrors.aliyun.com/ubuntu xenial-security InRelease [102 kB]      \nGet:5 http://mirrors.cloud.aliyuncs.com/ubuntu xenial-updates InRelease [102 kB]\nGet:6 http://mirrors.aliyun.com/ubuntu xenial-updates InRelease [102 kB]       \nGet:7 http://mirrors.cloud.aliyuncs.com/ubuntu xenial-proposed InRelease [253 kB]\n                                     ……\n                                     ……\nGet:45 http://mirrors.aliyun.com/ubuntu xenial-proposed/universe i386 Packages [31.6 kB]\nGet:46 http://mirrors.aliyun.com/ubuntu xenial-proposed/universe Translation-en [12.9 kB]\nIgn:47 https://oss-binaries.phusionpassenger.com/apt/passenger xenial InRelease \nIgn:48 https://oss-binaries.phusionpassenger.com/apt/passenger xenial Release   \nIgn:49 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main amd64 Packages\nIgn:50 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main i386 Packages \nIgn:51 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main all Packages\nIgn:52 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en_US\nIgn:53 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en\nIgn:49 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main amd64 Packages\nIgn:50 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main i386 Packages\nIgn:51 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main all Packages\nIgn:52 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en_US\nIgn:53 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en\nIgn:49 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main amd64 Packages\nIgn:50 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main i386 Packages\nIgn:51 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main all Packages\nIgn:52 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en_US\nIgn:53 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en\nIgn:49 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main amd64 Packages\nIgn:50 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main i386 Packages\nIgn:51 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main all Packages\nIgn:52 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en_US\nIgn:53 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en\nIgn:49 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main amd64 Packages\nIgn:50 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main i386 Packages\nIgn:51 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main all Packages\nIgn:52 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en_US\nIgn:53 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en\nErr:49 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main amd64 Packages\n  Bad header line\nIgn:50 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main i386 Packages\nIgn:51 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main all Packages\nIgn:52 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en_US\nIgn:53 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en\nFetched 6,467 kB in 2min 3s (52.4 kB/s)\nReading package lists... Done\nW: The repository &#39;https://oss-binaries.phusionpassenger.com/apt/passenger xenial Release&#39; does not have a Release file.\nN: Data from such a repository can&#39;t be authenticated and is therefore potentially dangerous to use.\nN: See apt-secure(8) manpage for repository creation and user configuration details.\nE: Failed to fetch https://oss-binaries.phusionpassenger.com/apt/passenger/dists/xenial/main/binary-amd64/Packages  Bad header line\nE: Some index files failed to download. They have been ignored, or old ones used instead.\n</code></pre>\n\n<p>与passenger相关的都是Ign或者Err了，然后报的<code>Bad header line</code>也不知道是怎么回事，总之到<code>apt-get update</code>这步永远也不能成功执行。</p>\n\n<p>服务器系统是Ubuntu 16.04 LTS，我在本地物理机上相同系统也试了，没有出现这个问题，passenger可以成功安装，所以应该不是服务器系统或者APT源的问题。有人遇到过这种情况吗，google, stackoverflow 试了各种方法折腾了一天一夜也没解决，准备放弃 改用Puma了。BTW，用老的方法<code>passenger-install-nginx-module</code>也不行，downloading  Nginx 之后就会卡住不动了。</p>\n\n<h3>解决方法</h3>\n\n<p>不得不说社区真强大，提问没多久就得到了@darkbaby123的解答：</p>\n\n<blockquote>\n<p>说说我前段时间碰到的类似问题，希望对你有帮助。当时也是装第三方 apt 源不成功，不过错误类型\n是 apt-get  update 报 403 。后来发现是阿里云的主机对 apt 配置了代理，应该是为了让内网\n机器访问自家的源加速，但影响了第三方源的获取。</p>\n\n<p>代理配置在 /etc/apt/apt.conf 里，把它注释掉再 update 就没问题了，注释用 # 号：\n<code>Acquire::http::Proxy &quot;http://mirrors.aliyun.com/&quot;;</code></p>\n</blockquote>\n\n<p><a href=\"https://ruby-china.org/topics/32310\">原文地址</a></p>\n','### 问题\r\n\r\n第一次部署Rails应用，参照[资料1](https://github.com/ruby-china/homeland/wiki/Ubuntu-12.04-%E4%B8%8A%E4%BD%BF%E7%94%A8-Nginx-Passenger-%E9%83%A8%E7%BD%B2-Ruby-on-Rails)  [资料2](https://ruby-china.org/wiki/deploy-rails-on-ubuntu-server)  [资料3](https://github.com/huacnlee/init.d)  [资料4](https://github.com/ruby-china/homeland/wiki/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85-Rails-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83)等资料在服务器上装好了ruby, rvm, 相关依赖等，但在安装passenger时，参照[此官方文档](https://www.phusionpassenger.com/library/install/nginx/install/oss/xenial/)，安装了秘钥和HTTP支持，也添加了APT源：\r\n`\r\nsudo sh -c \'echo deb https://oss-binaries.phusionpassenger.com/apt/passenger xenial main > /etc/apt/sources.list.d/passenger.list\'\r\n`\r\n\r\n但在执行 `sudo apt-get update`时遇到以下错误：\r\n\r\n\r\n    Hit:1 http://mirrors.cloud.aliyuncs.com/ubuntu xenial InRelease\r\n    Hit:2 http://mirrors.aliyun.com/ubuntu xenial InRelease\r\n    Get:3 http://mirrors.cloud.aliyuncs.com/ubuntu xenial-security InRelease [102 kB]\r\n    Get:4 http://mirrors.aliyun.com/ubuntu xenial-security InRelease [102 kB]      \r\n    Get:5 http://mirrors.cloud.aliyuncs.com/ubuntu xenial-updates InRelease [102 kB]\r\n    Get:6 http://mirrors.aliyun.com/ubuntu xenial-updates InRelease [102 kB]       \r\n    Get:7 http://mirrors.cloud.aliyuncs.com/ubuntu xenial-proposed InRelease [253 kB]\r\n                                         ……\r\n                                         ……\r\n    Get:45 http://mirrors.aliyun.com/ubuntu xenial-proposed/universe i386 Packages [31.6 kB]\r\n    Get:46 http://mirrors.aliyun.com/ubuntu xenial-proposed/universe Translation-en [12.9 kB]\r\n    Ign:47 https://oss-binaries.phusionpassenger.com/apt/passenger xenial InRelease \r\n    Ign:48 https://oss-binaries.phusionpassenger.com/apt/passenger xenial Release   \r\n    Ign:49 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main amd64 Packages\r\n    Ign:50 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main i386 Packages \r\n    Ign:51 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main all Packages\r\n    Ign:52 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en_US\r\n    Ign:53 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en\r\n    Ign:49 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main amd64 Packages\r\n    Ign:50 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main i386 Packages\r\n    Ign:51 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main all Packages\r\n    Ign:52 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en_US\r\n    Ign:53 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en\r\n    Ign:49 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main amd64 Packages\r\n    Ign:50 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main i386 Packages\r\n    Ign:51 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main all Packages\r\n    Ign:52 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en_US\r\n    Ign:53 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en\r\n    Ign:49 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main amd64 Packages\r\n    Ign:50 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main i386 Packages\r\n    Ign:51 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main all Packages\r\n    Ign:52 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en_US\r\n    Ign:53 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en\r\n    Ign:49 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main amd64 Packages\r\n    Ign:50 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main i386 Packages\r\n    Ign:51 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main all Packages\r\n    Ign:52 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en_US\r\n    Ign:53 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en\r\n    Err:49 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main amd64 Packages\r\n      Bad header line\r\n    Ign:50 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main i386 Packages\r\n    Ign:51 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main all Packages\r\n    Ign:52 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en_US\r\n    Ign:53 https://oss-binaries.phusionpassenger.com/apt/passenger xenial/main Translation-en\r\n    Fetched 6,467 kB in 2min 3s (52.4 kB/s)\r\n    Reading package lists... Done\r\n    W: The repository \'https://oss-binaries.phusionpassenger.com/apt/passenger xenial Release\' does not have a Release file.\r\n    N: Data from such a repository can\'t be authenticated and is therefore potentially dangerous to use.\r\n    N: See apt-secure(8) manpage for repository creation and user configuration details.\r\n    E: Failed to fetch https://oss-binaries.phusionpassenger.com/apt/passenger/dists/xenial/main/binary-amd64/Packages  Bad header line\r\n    E: Some index files failed to download. They have been ignored, or old ones used instead.\r\n\r\n\r\n与passenger相关的都是Ign或者Err了，然后报的`Bad header line`也不知道是怎么回事，总之到`apt-get update`这步永远也不能成功执行。\r\n\r\n服务器系统是Ubuntu 16.04 LTS，我在本地物理机上相同系统也试了，没有出现这个问题，passenger可以成功安装，所以应该不是服务器系统或者APT源的问题。有人遇到过这种情况吗，google, stackoverflow 试了各种方法折腾了一天一夜也没解决，准备放弃 改用Puma了。BTW，用老的方法`passenger-install-nginx-module`也不行，downloading  Nginx 之后就会卡住不动了。\r\n\r\n\r\n\r\n### 解决方法\r\n\r\n不得不说社区真强大，提问没多久就得到了@darkbaby123的解答：\r\n\r\n> 说说我前段时间碰到的类似问题，希望对你有帮助。当时也是装第三方 apt 源不成功，不过错误类型\r\n是 apt-get  update 报 403 。后来发现是阿里云的主机对 apt 配置了代理，应该是为了让内网\r\n机器访问自家的源加速，但影响了第三方源的获取。\r\n> \r\n> 代理配置在 /etc/apt/apt.conf 里，把它注释掉再 update 就没问题了，注释用 # 号：\r\n> `Acquire::http::Proxy \"http://mirrors.aliyun.com/\";`\r\n\r\n[原文地址](https://ruby-china.org/topics/32310)\r\n\r\n','2017-02','^^坑^^部署','2017-02-14 00:00:00','2017-02-15 00:00:00'),(10,'记我的第二次部署','<p>还记得第一次部署Rails应用时花了我很多时间，也踩了一些坑，那是我第一次自己独立完成一次开发，最后输入域名看到网站正常运行的那一瞬间，真的是非常欣慰的。</p>\n\n<p>当时本想把整个部署过程记录下来，但一直没来得及，转眼这又是第二次部署了，有了上次的经验，这次轻松了许多，参考相关资料，我把全过程简洁记录如下：</p>\n\n<ol>\n<li><p>生成ssh key 并添加到服务器：\n<code>ssh-keygen -t rsa</code></p>\n\n<p>如果已经有key, 直接显示ssh key内容： \n<code>cat ~/.ssh/id_rsa.pub</code></p></li>\n<li><p>以root用户登录服务器：\n<code>ssh root@[ip.address]</code></p></li>\n<li><p>创建部署用的用户：\n<code>useradd -m deploy</code></p>\n\n<p>将用户加入sudo群组：\n<code>adduser deploy sudo</code></p>\n\n<p>为deploy用户设置密码：\n<code>passwd deploy</code></p>\n\n<p>退出当前 SSH 链接，用 deploy 帐号重新登陆。</p>\n\n<p>如果此时用deploy无法登陆，可能是没有权限，尝试</p>\n\n<pre><code>mkdir /home/deploy/.ssh\ncp ~/.ssh/authorized_keys /home/deploy/.ssh/\nchown -R deploy.deploy /home/deploy/.ssh\nchmod -R go-rwx /home/deploy/.ssh  \n</code></pre></li>\n<li><p><code>apt-get update</code>  (<a href=\"http://renny.ren/ch/articles/9\">此处阿里云服务器可能有个坑</a>)</p></li>\n<li><p><a href=\"https://rvm.io/rvm/install\">安装rvm</a></p>\n\n<pre><code>gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3\n\n\\curl -sSL https://get.rvm.io | bash\n</code></pre>\n\n<p>安装完成后启动：<code>source ~/.rvm/scripts/rvm</code></p></li>\n<li><p>安装ruby\n<code>rvm use --install --default 2.3.1</code></p></li>\n<li><p>安装<a href=\"https://www.phusionpassenger.com/\">Passenger</a> + Nginx</p>\n\n<pre><code># Install our PGP key and add HTTPS support for APT\nsudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 561F9B9CAC40B2F7\nsudo apt-get install -y apt-transport-https ca-certificates\n\n# Add our APT repository\n\nsudo sh -c &#39;echo deb https://oss-binaries.phusionpassenger.com/apt/passenger xenial main &gt; /etc/apt/sources.list.d/passenger.list&#39;\nsudo apt-get update\n\n# Install Passenger + Nginx\n\nsudo apt-get install -y nginx-extras passenger\n</code></pre>\n\n<p>(此处的安装的Passenger是作为模块编译到nginx中，所以事先不能装nginx，如果装了要先卸载，否则会出现奇怪的错误)</p></li>\n<li><p>编辑<code>/etc/nginx/nginx.conf</code></p>\n\n<p>在http块中注释掉或是加入 <code>include /etc/nginx/passenger.conf;</code></p>\n\n<p><em>(此时可以用<code>nginx -t -c /etc/nignx/nginx.conf</code> 检查nginx配置是否正确</em></p>\n\n<p><em><code>sudo /usr/bin/passenger-config validate-install</code> 检查passenger的安装是否正确)</em></p>\n\n<p>编辑<code>/etc/nginx/passenger.conf</code></p>\n\n<p>将 <code>passenger_ruby /usr/bin/ruby;</code>一行 改为\n<code>passenger_ruby /home/deploy/.rvm/wrappers/default/ruby;</code></p></li>\n<li><p>重启Nginx</p>\n\n<p><code>sudo service nginx restart</code></p></li>\n<li><p>上传文件</p>\n\n<pre><code>mkdir -p /var/xxx/\ncd xxx\ngit clone xxx\nbundle install\nrails db:create db:migrate\nrails assets:precompile\n</code></pre></li>\n<li><p>修改nginx配置</p>\n\n<p>删除原有的默认网站配置：\n<code>rm /etc/nginx/sites-enabled/default</code></p>\n\n<p>新建网站配置：\n<code>touch /etc/nginx/sites-enabled/example.com.conf</code></p>\n\n<p>内容：</p>\n\n<pre><code>server {\n    listen 80 default;\n    server_name example.com; # 这里填写你真实域名\n    root /var/www/example.com/current/public; #网站目录\n    passenger_enabled on;\n}\n</code></pre></li>\n</ol>\n\n<p>最后重启nginx，Bingo!</p>\n\n<p>当然这其中还有很多大大小小的坑，欢迎交流。</p>\n','还记得第一次部署Rails应用时花了我很多时间，也踩了一些坑，那是我第一次自己独立完成一次开发，最后输入域名看到网站正常运行的那一瞬间，真的是非常欣慰的。\r\n\r\n当时本想把整个部署过程记录下来，但一直没来得及，转眼这又是第二次部署了，有了上次的经验，这次轻松了许多，参考相关资料，我把全过程简洁记录如下：\r\n\r\n1.  生成ssh key 并添加到服务器：\r\n    `ssh-keygen -t rsa`\r\n\r\n    如果已经有key, 直接显示ssh key内容： \r\n    `cat ~/.ssh/id_rsa.pub`\r\n\r\n2.  以root用户登录服务器：\r\n    `ssh root@[ip.address]`\r\n\r\n3.  创建部署用的用户：\r\n    `useradd -m deploy`\r\n\r\n    将用户加入sudo群组：\r\n    `adduser deploy sudo`\r\n\r\n    为deploy用户设置密码：\r\n    `passwd deploy`\r\n\r\n    退出当前 SSH 链接，用 deploy 帐号重新登陆。\r\n\r\n    如果此时用deploy无法登陆，可能是没有权限，尝试\r\n\r\n        mkdir /home/deploy/.ssh\r\n        cp ~/.ssh/authorized_keys /home/deploy/.ssh/\r\n        chown -R deploy.deploy /home/deploy/.ssh\r\n        chmod -R go-rwx /home/deploy/.ssh  \r\n\r\n4. `apt-get update`  ([此处阿里云服务器可能有个坑](http://renny.ren/ch/articles/9))\r\n\r\n5. [安装rvm](https://rvm.io/rvm/install)\r\n\r\n        gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3\r\n\r\n        \\curl -sSL https://get.rvm.io | bash\r\n\r\n    安装完成后启动：`source ~/.rvm/scripts/rvm`\r\n\r\n6. 安装ruby\r\n    `rvm use --install --default 2.3.1`\r\n\r\n7. 安装[Passenger](https://www.phusionpassenger.com/) + Nginx\r\n\r\n        # Install our PGP key and add HTTPS support for APT\r\n        sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 561F9B9CAC40B2F7\r\n        sudo apt-get install -y apt-transport-https ca-certificates\r\n\r\n        # Add our APT repository\r\n\r\n        sudo sh -c \'echo deb https://oss-binaries.phusionpassenger.com/apt/passenger xenial main > /etc/apt/sources.list.d/passenger.list\'\r\n        sudo apt-get update\r\n\r\n        # Install Passenger + Nginx\r\n\r\n        sudo apt-get install -y nginx-extras passenger\r\n\r\n    (此处的安装的Passenger是作为模块编译到nginx中，所以事先不能装nginx，如果装了要先卸载，否则会出现奇怪的错误)\r\n\r\n8. 编辑`/etc/nginx/nginx.conf`\r\n\r\n    在http块中注释掉或是加入 `include /etc/nginx/passenger.conf;`\r\n\r\n    *(此时可以用`nginx -t -c /etc/nignx/nginx.conf` 检查nginx配置是否正确*\r\n\r\n    *`sudo /usr/bin/passenger-config validate-install` 检查passenger的安装是否正确)*\r\n\r\n    编辑`/etc/nginx/passenger.conf`\r\n\r\n    将 `passenger_ruby /usr/bin/ruby;`一行 改为\r\n    `passenger_ruby /home/deploy/.rvm/wrappers/default/ruby;`\r\n\r\n9. 重启Nginx\r\n\r\n    `sudo service nginx restart`\r\n\r\n10. 上传文件\r\n\r\n        mkdir -p /var/xxx/\r\n        cd xxx\r\n        git clone xxx\r\n        bundle install\r\n        rails db:create db:migrate\r\n        rails assets:precompile\r\n\r\n11. 修改nginx配置\r\n\r\n    删除原有的默认网站配置：\r\n    `rm /etc/nginx/sites-enabled/default`\r\n\r\n    新建网站配置：\r\n    `touch /etc/nginx/sites-enabled/example.com.conf`\r\n\r\n    内容：\r\n\r\n        server {\r\n            listen 80 default;\r\n            server_name example.com; # 这里填写你真实域名\r\n            root /var/www/example.com/current/public; #网站目录\r\n            passenger_enabled on;\r\n        }\r\n\r\n最后重启nginx，Bingo!\r\n\r\n当然这其中还有很多大大小小的坑，欢迎交流。\r\n\r\n','2017-03','^^部署^^记录^^Rails','2017-03-17 05:56:01','2017-03-23 06:16:12'),(11,'各种报错解决集合','<p>Q: ERROR 2002 (HY000): Can&#39;t connect to local MySQL server through socket &#39;/tmp/mysql.sock&#39; (2)</p>\n\n<p>A:</p>\n\n<pre><code>sudo chown -R _mysql:mysql /usr/local/var/mysql      \nsudo mysql.server start\n</code></pre>\n\n<h3> </h3>\n\n<p>Q: /usr/lib/ruby/2.3.0/rubygems/dependency.rb:319:in `to_specs&#39;: Could not find &#39;bundler&#39; (&gt;= 0.a) among 16 total gem(s) (Gem::LoadError)</p>\n\n<p>A:</p>\n\n<pre><code>gem uninstall bundler\ngem install bundler  # don&#39;t run with &#39;sudo&#39;\n</code></pre>\n','Q: ERROR 2002 (HY000): Can\'t connect to local MySQL server through socket \'/tmp/mysql.sock\' (2)\r\n\r\nA:\r\n\r\n    sudo chown -R _mysql:mysql /usr/local/var/mysql      \r\n    sudo mysql.server start\r\n\r\n<h3> </h3>\r\n\r\n\r\nQ: /usr/lib/ruby/2.3.0/rubygems/dependency.rb:319:in `to_specs\': Could not find \'bundler\' (>= 0.a) among 16 total gem(s) (Gem::LoadError)\r\n\r\nA:\r\n\r\n    gem uninstall bundler\r\n    gem install bundler  # don\'t run with \'sudo\'','2016-11','^^疑难杂症','2016-11-19 06:09:55','2017-03-22 14:20:40');
/*!40000 ALTER TABLE `articles` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `comments`
--

DROP TABLE IF EXISTS `comments`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `comments` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `commenter` varchar(255) DEFAULT NULL,
  `body` text,
  `article_id` int(11) DEFAULT NULL,
  `created_at` datetime NOT NULL,
  `updated_at` datetime NOT NULL,
  PRIMARY KEY (`id`),
  KEY `index_comments_on_article_id` (`article_id`),
  CONSTRAINT `fk_rails_3bf61a60d3` FOREIGN KEY (`article_id`) REFERENCES `articles` (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `comments`
--

LOCK TABLES `comments` WRITE;
/*!40000 ALTER TABLE `comments` DISABLE KEYS */;
/*!40000 ALTER TABLE `comments` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `schema_migrations`
--

DROP TABLE IF EXISTS `schema_migrations`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `schema_migrations` (
  `version` varchar(255) NOT NULL,
  PRIMARY KEY (`version`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `schema_migrations`
--

LOCK TABLES `schema_migrations` WRITE;
/*!40000 ALTER TABLE `schema_migrations` DISABLE KEYS */;
INSERT INTO `schema_migrations` VALUES ('20160921062856'),('20160922145535'),('20170125063834'),('20170306100956');
/*!40000 ALTER TABLE `schema_migrations` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tags`
--

DROP TABLE IF EXISTS `tags`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `tags` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `tag_name` varchar(255) DEFAULT NULL,
  `created_at` datetime NOT NULL,
  `updated_at` datetime NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=15 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tags`
--

LOCK TABLES `tags` WRITE;
/*!40000 ALTER TABLE `tags` DISABLE KEYS */;
INSERT INTO `tags` VALUES (1,'总结','2017-03-10 06:00:19','2017-03-10 06:00:19'),(2,'Git','2017-03-15 07:58:37','2017-03-15 07:58:37'),(3,'Ruby','2017-03-16 01:47:57','2017-03-16 01:47:57'),(4,'翻译','2017-03-16 03:13:24','2017-03-16 03:13:24'),(5,'数据库','2017-03-16 03:41:52','2017-03-16 03:41:52'),(6,'JS','2017-03-16 11:38:20','2017-03-16 11:38:20'),(7,'CSS','2017-03-16 11:38:26','2017-03-16 11:38:26'),(8,'长文','2017-03-16 12:25:42','2017-03-16 12:25:42'),(9,'感想','2017-03-16 12:26:12','2017-03-16 12:26:12'),(10,'坑','2017-03-17 03:52:57','2017-03-17 03:52:57'),(11,'部署','2017-03-17 05:54:10','2017-03-17 05:54:10'),(12,'记录','2017-03-17 05:55:24','2017-03-17 05:55:24'),(13,'Rails','2017-03-17 09:43:00','2017-03-17 09:43:00'),(14,'疑难杂症','2017-03-19 06:08:29','2017-03-19 06:08:29');
/*!40000 ALTER TABLE `tags` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2017-03-23 15:07:24
